<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UrbanBlind - –†–∞–±–æ—Ç–∞—é—â–∏–π –ø—Ä–æ—Ç–æ—Ç–∏–ø</title>
    <style>
        /* –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π CSS –¥–ª—è —Ä–∞–±–æ—Ç—ã */
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; display: flex; height: 100vh; }
        #map { flex: 3; }
        #sidebar { flex: 1; padding: 15px; overflow-y: auto; background: #f0f0f0; }
        .card { background: white; margin-bottom: 10px; padding: 10px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .data-row { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #eee; }
        .status { padding: 5px; font-size: 12px; }
        .status-ok { color: green; }
        .status-warning { color: orange; }
        .status-error { color: red; }
        #coords-display { font-size: 12px; color: gray; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="sidebar">
        <div class="status" id="status">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</div>
        <div id="coords-display">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: --, --</div>
        <div class="card">
            <h3>–ò–Ω–¥–µ–∫—Å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</h3>
            <div id="safety-index-value">--</div>
            <div id="safety-label">-</div>
        </div>
        <div class="card">
            <h3>–ü–æ–≥–æ–¥–∞</h3>
            <div class="data-row"><span>–¢–µ–º–ø:</span><span id="w-temp">-</span></div>
            <div class="data-row"><span>–£—Å–ª–æ–≤–∏—è:</span><span id="w-cond">-</span></div>
            <div class="data-row"><span>–í–µ—Ç–µ—Ä:</span><span id="w-wind">-</span></div>
            <div class="data-row"><span>–í–ª–∞–∂–Ω–æ—Å—Ç—å:</span><span id="w-hum">-</span></div>
        </div>
        <div class="card">
            <h3>–§–∞–∫—Ç–æ—Ä—ã —Ä–∏—Å–∫–∞</h3>
            <div class="data-row"><span>–®—É–º:</span><span id="noise-value">-</span> (<span id="noise-risk">-</span>)</div>
            <div class="data-row"><span>–ü–ª–æ—Ç–Ω–æ—Å—Ç—å:</span><span id="crowd-value">-</span> (<span id="crowd-risk">-</span>)</div>
            <div class="data-row"><span>–û—Å–≤–µ—â–µ–Ω–∏–µ:</span><span id="light-value">-</span> (<span id="light-risk">-</span>)</div>
            <div class="data-row"><span>–í—Ä–µ–º—è:</span><span id="time-value">-</span> (<span id="time-risk">-</span>)</div>
            <div class="data-row"><span>–î–µ–Ω—å:</span><span id="day-value">-</span> (<span id="day-risk">-</span>)</div>
        </div>
        <div class="card">
            <h3>–ü—Ä–æ–±–∫–∏</h3>
            <div class="data-row"><span>–£—Ä–æ–≤–µ–Ω—å:</span><span id="t-level">-</span></div>
            <div class="data-row"><span>–°—Ç–∞—Ç—É—Å:</span><span id="t-status">-</span></div>
        </div>
        <button id="refresh-btn">–û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ</button>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç—ã -->
    <script src="https://api-maps.yandex.ru/2.1/?apikey=c2763cd1-5a14-4131-842c-2bbd60932c52&lang=ru_RU"></script>
    <script>
        // --- –ù–ê–°–¢–†–û–ô–ö–ò ---
        const CONFIG = {
            throttleMs: 600,
            minDragDistance: 0.001,
            defaultCoords: [55.7961, 49.1064],
            debugMode: true, // –í–∫–ª—é—á–∞–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            overpassUrl: 'https://overpass-api.de/api/interpreter',
            openMeteoUrl: 'https://api.open-meteo.com/v1/forecast',
            sunriseUrl: 'https://api.sunrise-sunset.org/json',
            overpassTimeout: 25,
            cacheDuration: 300000, // 5 –º–∏–Ω—É—Ç
            fallbackRadius: 200
        };

        // --- –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ---
        let map, placemark;
        let currentCoords = [...CONFIG.defaultCoords];
        let lastRequestTime = 0;
        let lastRequestCoords = null;
        let apiCache = new Map();
        let isDragging = false; // –î–æ–±–∞–≤–∏–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è

        // --- –£–¢–ò–õ–ò–¢–´ ---
        function throttle(func, limitMs) {
            return function(...args) {
                const now = Date.now();
                const coords = args[0];
                if (lastRequestCoords) {
                    const dist = Math.hypot(coords[0] - lastRequestCoords[0], coords[1] - lastRequestCoords[1]);
                    if (dist < CONFIG.minDragDistance && now - lastRequestTime < limitMs * 2) {
                        return;
                    }
                }
                if (now - lastRequestTime >= limitMs) {
                    lastRequestTime = now;
                    lastRequestCoords = [...coords];
                    func.apply(this, args);
                } else {
                    if (pendingRequest) clearTimeout(pendingRequest);
                    pendingRequest = setTimeout(() => {
                        lastRequestTime = Date.now();
                        lastRequestCoords = [...coords];
                        func.apply(this, args);
                        pendingRequest = null;
                    }, limitMs - (now - lastRequestTime));
                }
            };
        }

        let pendingRequest = null; // –û–±—ä—è–≤–ª–µ–Ω–∞ –∑–¥–µ—Å—å –¥–ª—è throttle

        function formatCoord(val) { return val.toFixed(4); }

        function getCachedData(key) {
            const cached = apiCache.get(key);
            if (cached && Date.now() - cached.time < CONFIG.cacheDuration) {
                return cached.data;
            }
            return null;
        }

        function setCachedData(key, data) {
            apiCache.set(key, { data, time: Date.now() });
        }

        function updateStatus(state, text) {
            const el = document.getElementById('status');
            el.className = `status status-${state}`;
            el.textContent = text;
        }

        // --- –ü–û–ì–û–î–ê (Open-Meteo) ---
        async function getWeatherFromOpenMeteo(lat, lon) {
            const cacheKey = `weather:${lat.toFixed(2)},${lon.toFixed(2)}`;
            const cached = getCachedData(cacheKey);
            if (cached) {
                if (CONFIG.debugMode) console.log("Weather cache hit:", cacheKey);
                return cached;
            }
            try {
                const url = `${CONFIG.openMeteoUrl}?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=relative_humidity_2m&timezone=auto`;
                if (CONFIG.debugMode) console.log("Fetching weather from:", url);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                if (!data.current_weather) throw new Error('No weather data');

                const d = data.current_weather;
                const w = {
                    temp: d.temperature ?? 'N/A',
                    wind: `${d.windspeed ?? 'N/A'} km/h`,
                    wind_dir: d.winddirection,
                    condition: getWeatherCondition(d.weathercode),
                    humidity: 'N/A'
                };

                // –ü–æ–ª—É—á–∞–µ–º –≤–ª–∞–∂–Ω–æ—Å—Ç—å
                if (data.hourly?.relative_humidity_2m && data.hourly.time) {
                    const nowISO = new Date().toISOString().slice(0, 16).replace(/-/g, '/').replace('T', ' ') + '00';
                    const index = data.hourly.time.findIndex(t => t.replace('T', ' ').startsWith(nowISO.slice(0, -3)));
                    w.humidity = index !== -1 ? data.hourly.relative_humidity_2m[index] : data.hourly.relative_humidity_2m[0];
                }

                setCachedData(cacheKey, w);
                if (CONFIG.debugMode) console.log("Weather fetched:", w);
                return w;
            } catch (e) {
                console.error("Open-Meteo Error:", e);
                updateStatus('warning', '–ü–æ–≥–æ–¥–∞: –æ—à–∏–±–∫–∞ API');
                return { temp: 'N/A', wind: 'N/A', condition: '–û—à–∏–±–∫–∞', humidity: 'N/A' };
            }
        }

        function getWeatherCondition(code) {
            const c = {0:'‚òÄÔ∏è –Ø—Å–Ω–æ',1:'üå§Ô∏è –Ø—Å–Ω–æ',2:'‚õÖ –û–±–ª.',3:'‚òÅÔ∏è –ü–∞—Å–º—É—Ä–Ω–æ',45:'üå´Ô∏è –¢—É–º–∞–Ω',48:'‚ùÑÔ∏è –ò–Ω–µ–π',51:'üíß –ú–æ—Ä–æ—Å—å',53:'üíß –ú–æ—Ä–æ—Å—å',55:'üíß –ú–æ—Ä–æ—Å—å',61:'üåßÔ∏è –î–æ–∂–¥—å',63:'üåßÔ∏è –î–æ–∂–¥—å',65:'üåßÔ∏è –°–∏–ª—å–Ω—ã–π',71:'‚ùÑÔ∏è –°–Ω–µ–≥',73:'‚ùÑÔ∏è –°–Ω–µ–≥',75:'‚ùÑÔ∏è –°–∏–ª—å–Ω—ã–π',80:'üå¶Ô∏è –õ–∏–≤–µ–Ω—å',81:'üå¶Ô∏è –õ–∏–≤–µ–Ω—å',82:'üå¶Ô∏è –°–∏–ª—å–Ω—ã–π',95:'‚õàÔ∏è –ì—Ä–æ–∑–∞',96:'‚õàÔ∏è –ì—Ä–æ–∑–∞',99:'‚õàÔ∏è –°–∏–ª—å–Ω–∞—è'};
            return c[code] || `‚ùì ${code}`;
        }

        // --- –ü–†–û–ë–ö–ò (FAKE/–í–†–ï–ú–Ø –°–£–¢–û–ö) ---
        // –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç—ã —Å–ª–æ–π –ø—Ä–æ–±–æ–∫ –±—É–¥–µ—Ç –æ—Ç–¥–µ–ª—å–Ω–æ –Ω–∞ –∫–∞—Ä—Ç–µ
        async function getTrafficFake(lat, lon) {
            const hour = new Date().getHours();
            let level, status;
            if ((hour >= 7 && hour < 10) || (hour >= 17 && hour < 20)) { level = 8; status = '–ü–∏–∫–æ–≤–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞'; }
            else if (hour >= 10 && hour < 17) { level = 4; status = '–î–Ω–µ–≤–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å'; }
            else { level = 2; status = '–ù–æ—á–Ω–∞—è —Ç–∏—à–∏–Ω–∞'; }
            return { level, status, source: 'fake' };
        }

        // --- –®–£–ú (OSM) ---
        async function getNoiseFromOsm(lat, lon) {
            const cacheKey = `noise_osm:${lat.toFixed(4)},${lon.toFixed(4)}`;
            const cached = getCachedData(cacheKey);
            if (cached) {
                if (CONFIG.debugMode) console.log("Noise OSM cache hit:", cacheKey);
                return cached;
            }
            try {
                const r = CONFIG.fallbackRadius;
                const q = `[out:json][timeout:${CONFIG.overpassTimeout}];(node["amenity"~"cafe|bar|pub|fast_food|restaurant"](around:${r},${lat},${lon});way["highway"~"primary|secondary|tertiary"](around:${r},${lat},${lon}););out count;`;
                if (CONFIG.debugMode) console.log("Fetching noise OSM with query:", q);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                const response = await fetch(CONFIG.overpassUrl, {
                    method: 'POST',
                    body: `data=${encodeURIComponent(q)}`,
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                const count = data.elements?.length || 0;

                let level, risk, desc;
                if (count > 40) { level = 75; risk = 80; desc = '–û—á–µ–Ω—å —à—É–º–Ω–æ'; }
                else if (count > 25) { level = 65; risk = 65; desc = '–®—É–º–Ω–æ'; }
                else if (count > 15) { level = 55; risk = 45; desc = '–£–º–µ—Ä–µ–Ω–Ω—ã–π'; }
                else if (count > 5) { level = 45; risk = 30; desc = '–¢–∏—Ö–æ'; }
                else { level = 35; risk = 15; desc = '–û—á–µ–Ω—å —Ç–∏—Ö–æ'; }

                const result = { level, risk, desc, source: 'osm_based' };
                setCachedData(cacheKey, result);
                if (CONFIG.debugMode) console.log("Noise OSM result:", result);
                return result;
            } catch (e) {
                console.error("OSM Noise Error:", e);
                updateStatus('warning', '–®—É–º: –æ—à–∏–±–∫–∞ OSM');
                const fb = { level: 50, risk: 40, desc: 'OSM Err', source: 'fallback' };
                setCachedData(cacheKey, fb);
                return fb;
            }
        }

        // --- –ü–õ–û–¢–ù–û–°–¢–¨ (OSM) ---
        async function getCrowdFromOsm(lat, lon) {
            const cacheKey = `crowd_osm:${lat.toFixed(4)},${lon.toFixed(4)}`;
            const cached = getCachedData(cacheKey);
            if (cached) {
                if (CONFIG.debugMode) console.log("Crowd OSM cache hit:", cacheKey);
                return cached;
            }
            try {
                const r = CONFIG.fallbackRadius;
                const q = `[out:json][timeout:${CONFIG.overpassTimeout}];(node["amenity"~"cafe|restaurant|fuel|bank"](around:${r},${lat},${lon});node["shop"](around:${r},${lat},${lon});node["public_transport"="station"](around:${r},${lat},${lon}););out count;`;
                if (CONFIG.debugMode) console.log("Fetching crowd OSM with query:", q);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                const response = await fetch(CONFIG.overpassUrl, {
                    method: 'POST',
                    body: `data=${encodeURIComponent(q)}`,
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                const count = data.elements?.length || 0;

                let level, risk, desc;
                if (count > 50) { level = 90; risk = 85; desc = '–û—á. –≤—ã—Å–æ–∫–∞—è'; }
                else if (count > 30) { level = 70; risk = 65; desc = '–í—ã—Å–æ–∫–∞—è'; }
                else if (count > 15) { level = 50; risk = 45; desc = '–°—Ä–µ–¥–Ω—è—è'; }
                else if (count > 5) { level = 30; risk = 25; desc = '–ù–∏–∑–∫–∞—è'; }
                else { level = 15; risk = 15; desc = '–û—á. –Ω–∏–∑–∫–∞—è'; }

                const result = { level, risk, desc, source: 'osm_based' };
                setCachedData(cacheKey, result);
                if (CONFIG.debugMode) console.log("Crowd OSM result:", result);
                return result;
            } catch (e) {
                console.error("OSM Crowd Error:", e);
                updateStatus('warning', '–ü–ª–æ—Ç–Ω–æ—Å—Ç—å: –æ—à–∏–±–∫–∞ OSM');
                const fb = { level: 35, risk: 25, desc: 'OSM Err', source: 'fallback' };
                setCachedData(cacheKey, fb);
                return fb;
            }
        }

        // --- –û–°–í–ï–©–ï–ù–ù–û–°–¢–¨ (OSM + SUNRISE) ---
        async function getLightFromOsmAndSunrise(lat, lon) {
            const cacheKey = `light_osm_sunrise:${lat.toFixed(4)},${lon.toFixed(4)}`;
            const cached = getCachedData(cacheKey);
            if (cached) {
                if (CONFIG.debugMode) console.log("Light OSM/Sunrise cache hit:", cacheKey);
                return cached;
            }
            try {
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–µ–Ω—å/–Ω–æ—á—å
                const timeInfo = await getTimeOfDayByLocation(lat, lon);
                if (timeInfo.isDaytime) {
                    const result = { level: 95, risk: 10, desc: '–î–µ–Ω—å (—Å–æ–ª–Ω—Ü–µ)', source: 'time_based' };
                    setCachedData(cacheKey, result);
                    if (CONFIG.debugMode) console.log("Light daytime result:", result);
                    return result;
                }

                // –ù–æ—á—å—é —Å—á–∏—Ç–∞–µ–º —Ñ–æ–Ω–∞—Ä–∏
                const r = CONFIG.fallbackRadius;
                const q = `[out:json][timeout:${CONFIG.overpassTimeout}];(node["highway"="street_lamp"](around:${r},${lat},${lon});node["man_made"="street_lamp"](around:${r},${lat},${lon}););out count;`;
                if (CONFIG.debugMode) console.log("Fetching light OSM with query:", q);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                const response = await fetch(CONFIG.overpassUrl, {
                    method: 'POST',
                    body: `data=${encodeURIComponent(q)}`,
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                const count = data.elements?.length || 0;

                let level, risk, desc;
                if (count > 20) { level = 85; risk = 15; desc = '–•–æ—Ä. –æ—Å–≤–µ—â–µ–Ω–∏–µ'; }
                else if (count > 10) { level = 65; risk = 35; desc = '–°—Ä–µ–¥–Ω–µ–µ'; }
                else if (count > 3) { level = 45; risk = 55; desc = '–°–ª–∞–±–æ–µ'; }
                else { level = 25; risk = 70; desc = '–¢–µ–º–Ω–æ'; }

                const result = { level, risk, desc, source: 'osm_based' };
                setCachedData(cacheKey, result);
                if (CONFIG.debugMode) console.log("Light nighttime result:", result);
                return result;
            } catch (e) {
                console.error("OSM/Sunrise Light Error:", e);
                updateStatus('warning', '–û—Å–≤–µ—â–µ–Ω–∏–µ: –æ—à–∏–±–∫–∞ OSM/Sunrise');
                const fb = { level: 40, risk: 50, desc: 'Err', source: 'fallback' };
                setCachedData(cacheKey, fb);
                return fb;
            }
        }

        // --- –í–†–ï–ú–Ø –°–£–¢–û–ö (SUNRISE API) ---
        async function getSunriseSunset(lat, lon) {
            const cacheKey = `sunrise_sunset:${lat.toFixed(4)},${lon.toFixed(4)}`;
            const cached = getCachedData(cacheKey);
            if (cached) {
                if (CONFIG.debugMode) console.log("Sunrise/Sunset cache hit:", cacheKey);
                return cached;
            }
            try {
                const url = `${CONFIG.sunriseUrl}?lat=${lat}&lng=${lon}&date=today&formatted=0`;
                if (CONFIG.debugMode) console.log("Fetching sunrise/sunset from:", url);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                if (!data.results?.sunrise) throw new Error('Invalid response');

                const result = {
                    sunrise: new Date(data.results.sunrise),
                    sunset: new Date(data.results.sunset)
                };
                setCachedData(cacheKey, result);
                if (CONFIG.debugMode) console.log("Sunrise/Sunset fetched:", result);
                return result;
            } catch (e) {
                console.error("Sunrise/Sunset Error:", e);
                // –ù–µ –∫—ç—à–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
                return null;
            }
        }

        async function getTimeOfDayByLocation(lat, lon) {
            const now = new Date();
            const sunData = await getSunriseSunset(lat, lon);
            const hour = now.getHours();

            if (!sunData) {
                const isDaytime = hour >= 6 && hour < 22;
                const tod = hour < 6 ? '–ù–æ—á—å' : hour < 12 ? '–£—Ç—Ä–æ' : hour < 18 ? '–î–µ–Ω—å' : '–í–µ—á–µ—Ä';
                return { timeOfDay: tod, isDaytime, description: '–û—Ü–µ–Ω–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏' };
            }

            const isDaytime = now >= sunData.sunrise && now < sunData.sunset;
            let tod, desc;
            if (now < sunData.sunrise) { tod = '–ù–æ—á—å'; desc = '–¢–µ–º–Ω–æ'; }
            else if (now < new Date(sunData.sunrise.getTime() + 2 * 60 * 60 * 1000)) { tod = '–£—Ç—Ä–æ'; desc = '–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å'; }
            else if (now < sunData.sunset) { tod = '–î–µ–Ω—å'; desc = '–í—ã—Å–æ–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å'; }
            else { tod = '–ù–æ—á—å'; desc = '–¢–µ–º–Ω–æ'; }
            return { timeOfDay: tod, isDaytime, description: desc };
        }

        // --- –†–ê–°–ß–ï–¢ –†–ò–°–ö–û–í ---
        async function calculateRiskFactors(coords) {
            const [lat, lon] = coords;
            const now = new Date();
            const day = now.getDay();
            const timeInfo = await getTimeOfDayByLocation(lat, lon);

            // –í—Ä–µ–º—è —Å—É—Ç–æ–∫
            let timeRisk = timeInfo.timeOfDay === '–ù–æ—á—å' ? 75 : timeInfo.timeOfDay === '–í–µ—á–µ—Ä' ? 60 : timeInfo.timeOfDay === '–£—Ç—Ä–æ' ? 30 : 40;
            const dayNames = ['–í—Å', '–ü–Ω', '–í—Ç', '–°—Ä', '–ß—Ç', '–ü—Ç', '–°–±'];
            const dayName = dayNames[day];
            let dayRisk = (day === 0 || day === 6) ? 35 : day === 5 ? 70 : 55;

            const [noise, crowd, light, weather, traffic] = await Promise.allSettled([
                getNoiseFromOsm(lat, lon),
                getCrowdFromOsm(lat, lon),
                getLightFromOsmAndSunrise(lat, lon),
                getWeatherFromOpenMeteo(lat, lon),
                getTrafficFake(lat, lon) // –í—Å–µ–≥–¥–∞ fake
            ]);

            const n = noise.status === 'fulfilled' ? noise.value : { level: 50, risk: 40, desc: 'Err', source: 'error' };
            const c = crowd.status === 'fulfilled' ? crowd.value : { level: 35, risk: 25, desc: 'Err', source: 'error' };
            const l = light.status === 'fulfilled' ? light.value : { level: 40, risk: 50, desc: 'Err', source: 'error' };
            const w = weather.status === 'fulfilled' ? weather.value : { temp: 'N/A', condition: 'Err' };
            const t = traffic.status === 'fulfilled' ? traffic.value : { level: 5, status: 'Err' };

            const avgRisk = (n.risk + c.risk + l.risk + timeRisk + dayRisk + (t.level * 10)) / 6;
            const safetyIndex = Math.round(100 - avgRisk);

            return {
                noise: n, crowd: c, light: l,
                time: { value: timeInfo.timeOfDay, risk: timeRisk },
                day: { value: dayName, risk: dayRisk },
                weather: w, traffic: t, safetyIndex,
                timestamp: new Date().toLocaleString()
            };
        }

        // --- –û–¢–†–ò–°–û–í–ö–ê ---
        function renderData(risks) {
            document.getElementById('safety-index-value').textContent = risks.safetyIndex;
            document.getElementById('safety-label').textContent = risks.safetyIndex > 70 ? '–í—ã—Å–æ–∫–∞—è' : risks.safetyIndex > 40 ? '–°—Ä–µ–¥–Ω—è—è' : '–ù–∏–∑–∫–∞—è';

            document.getElementById('w-temp').textContent = `${risks.weather.temp}¬∞C`;
            document.getElementById('w-cond').textContent = risks.weather.condition;
            document.getElementById('w-wind').textContent = risks.weather.wind;
            document.getElementById('w-hum').textContent = `${risks.weather.humidity}%`;

            document.getElementById('noise-value').textContent = risks.noise.desc;
            document.getElementById('noise-risk').textContent = `${risks.noise.risk}%`;
            document.getElementById('crowd-value').textContent = risks.crowd.desc;
            document.getElementById('crowd-risk').textContent = `${risks.crowd.risk}%`;
            document.getElementById('light-value').textContent = risks.light.desc;
            document.getElementById('light-risk').textContent = `${risks.light.risk}%`;
            document.getElementById('time-value').textContent = risks.time.value;
            document.getElementById('time-risk').textContent = `${risks.time.risk}%`;
            document.getElementById('day-value').textContent = risks.day.value;
            document.getElementById('day-risk').textContent = `${risks.day.risk}%`;

            document.getElementById('t-level').textContent = `${risks.traffic.level}/10`;
            document.getElementById('t-status').textContent = risks.traffic.status;
        }

        // --- –ó–ê–ü–†–û–° –î–ê–ù–ù–´–• ---
        async function requestWeatherData(coords, force = false) {
            if (!force && lastRequestCoords &&
                Math.abs(coords[0] - lastRequestCoords[0]) < 0.0001 &&
                Math.abs(coords[1] - lastRequestCoords[1]) < 0.0001) {
                return;
            }

            updateStatus('warning', '–ó–∞–≥—Ä—É–∑–∫–∞...');
            try {
                const risks = await calculateRiskFactors(coords);
                renderData(risks);
                lastRequestCoords = [...coords];
                updateStatus('ok', `–û–±–Ω–æ–≤–ª–µ–Ω–æ: ${risks.timestamp}`);
            } catch (e) {
                console.error("Main request error:", e);
                updateStatus('error', '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö');
            }
        }

        const throttledRequest = throttle(
            (coords) => requestWeatherData(coords, false),
            CONFIG.throttleMs
        );

        // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–ê–†–¢–´ ---
ymaps.ready(init);

function init() {
    try {
        map = new ymaps.Map('map', {
            center: CONFIG.defaultCoords,
            zoom: 13,
            controls: ['zoomControl', 'fullscreenControl', 'geolocationControl']
        });

        // --- –°–õ–û–ô –ü–†–û–ë–û–ö –Ø–ù–î–ï–ö–° (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –°–ü–û–°–û–ë) ---
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç—É–ø–µ–Ω –ª–∏ –º–æ–¥—É–ª—å –ø—Ä–æ–±–æ–∫
        if (ymaps.traffic) {
            // –°–æ–∑–¥–∞—ë–º —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–Ω—Ç—Ä–æ–ª–∞ –ø—Ä–æ–±–æ–∫
            const trafficControl = new ymaps.traffic.control.Manager({
                // –£–∫–∞–∑—ã–≤–∞–µ–º, —á—Ç–æ —Å–ª–æ–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤—Å–µ–≥–¥–∞ –≤–∏–¥–∏–º—ã–º
                state: { visible: true }
            });
            // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞ –∫–∞—Ä—Ç—É
            map.controls.add(trafficControl);
            console.log("Yandex Traffic control added successfully.");
        } else {
            console.warn("Yandex Maps traffic module is not available.");
            // –ï—Å–ª–∏ –º–æ–¥—É–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –º–æ–∂–Ω–æ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å—Ç–∞—Ä—ã–π –º–µ—Ç–æ–¥, –Ω–æ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–∫–∏
            // –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ —Å–æ–æ–±—â–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.
             console.warn("Trying legacy traffic layer method...");
             try {
                 // –ü–æ–ø—ã—Ç–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —É—Å—Ç–∞—Ä–µ–≤—à–∏–π —Å–ª–æ–π –Ω–∞–ø—Ä—è–º—É—é (–º–æ–∂–µ—Ç –Ω–µ —Å—Ä–∞–±–æ—Ç–∞—Ç—å)
                 const trafficLayer = new ymaps.layer.TrafficLayer({ trafficProvider: 'yandex#actual' });
                 trafficLayer.setMap(map);
                 console.log("Legacy traffic layer added (might not work).");
             } catch(e_legacy) {
                 console.error("Failed to add legacy traffic layer:", e_legacy);
                 // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ, –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å
                 updateStatus('warning', '–ü—Ä–æ–±–∫–∏: —Å–ª–æ–π –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
             }
        }
        // --------------------------

        createPlacemark(CONFIG.defaultCoords);

        mapInitialized = true;
        map.events.add('click', function(e) {
            const coords = e.get('coords');
            movePlacemark(coords, true);
        });

        requestWeatherData(CONFIG.defaultCoords, true);
        document.getElementById('btn-force-refresh').addEventListener('click', forceRefresh);
    } catch (error) {
        console.error("Yandex Maps Init Error:", error);
        showMapError(error);
    }
}

    </script>
</body>
</html>
