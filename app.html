<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>UrbanBlind - –ê–Ω–∞–ª–∏–∑ —Ä–∏—Å–∫–æ–≤ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
:root {
--glass-bg: rgba(255, 255, 255, 0.85);
--glass-border: rgba(0, 0, 0, 0.08);
--glass-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
--glass-blur: blur(12px);
--primary-color: #34495e;
--secondary-color: #2c3e50;
--accent-blue: #3498db;
--accent-orange: #e67e22;
--accent-purple: #9b59b6;
--accent-green: #27ae60;
--text-primary: #2c3e50;
--text-secondary: #7f8c8d;
--text-muted: #95a5a6;
--noise-color: #f39c12;
--crowd-color: #9b59b6;
--light-color: #3498db;
--time-color: #1abc9c;
--day-color: #e67e22;
}
body { display: flex; height: 100vh; overflow: hidden; background: linear-gradient(135deg, #f5f7fa 0%, #e4e7eb 100%); width: 100vw; }
#ub-logo {
position: fixed; top: 5px; left: 40px; font-size: 28px; font-weight: 800;
color: var(--secondary-color); z-index: 100; text-shadow: 0 2px 4px rgba(0,0,0,0.05);
letter-spacing: -1px; background: #ffffff; border-radius: 12px;
padding: 5px 16px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
border: 1px solid rgba(0, 0, 0, 0.08); transition: all 0.3s ease;
}
#ub-logo:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15); }
#map { flex: 2; height: 100%; min-width: 0; position: relative; background: #e8eaed; }
#map-error {
position: absolute; top: 0; left: 0; right: 0; bottom: 0;
background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
color: white; display: none; flex-direction: column;
align-items: center; justify-content: center; text-align: center;
padding: 20px; z-index: 1000; animation: fadeIn 0.5s ease;
}
#map-error.visible { display: flex; }
#map-error h2 { margin-bottom: 15px; font-size: 24px; }
#map-error p { margin-bottom: 20px; max-width: 400px; line-height: 1.6; }
#map-error button {
padding: 12px 24px; background: rgba(255, 255, 255, 0.15);
color: white; border: 1px solid rgba(255, 255, 255, 0.3);
border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px;
transition: all 0.3s ease;
}
#map-error button:hover { background: rgba(255, 255, 255, 0.25); transform: translateY(-2px); }
#sidebar {
flex: 1; background: var(--glass-bg); backdrop-filter: var(--glass-blur);
-webkit-backdrop-filter: var(--glass-blur); padding: 20px;
overflow-y: auto; box-shadow: var(--glass-shadow);
max-width: 500px; display: flex; flex-direction: column;
z-index: 10; min-width: 350px; position: relative;
}
.instructions-container {
position: sticky; top: 0; z-index: 100; background: var(--glass-bg);
backdrop-filter: var(--glass-blur); -webkit-backdrop-filter: var(--glass-blur);
border-radius: 12px; margin: -20px -20px 20px -20px;
padding: 15px 20px; box-shadow: var(--glass-shadow);
}
.instructions {
background: rgba(238, 247, 255, 0.7); border-left: 4px solid var(--accent-blue);
padding: 12px; border-radius: 0 4px 4px 0; font-size: 13px; color: var(--text-primary);
}
.instructions h3 { font-weight: 600; margin-bottom: 8px; color: var(--secondary-color); display: flex; align-items: center; gap: 8px; }
.instructions ul { padding-left: 20px; }
.instructions li { margin-bottom: 5px; line-height: 1.4; }
.sidebar-header {
margin-bottom: 20px; padding-bottom: 15px;
border-bottom: 1px solid var(--glass-border);
position: sticky; top: 0; background: var(--glass-bg); z-index: 100;
}
h1 { font-size: 20px; color: var(--secondary-color); margin-bottom: 5px; font-weight: 600; }
.subtitle { color: var(--text-muted); font-size: 12px; font-weight: 500; }
.api-status {
display: flex; align-items: center; font-size: 11px;
color: var(--text-muted); margin-top: 12px; flex-wrap: wrap;
gap: 8px; background: rgba(0, 0, 0, 0.03); padding: 8px 12px; border-radius: 8px;
}
.status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 4px; }
.status-good { background-color: var(--accent-green); }
.status-warning { background-color: var(--accent-orange); }
.status-error { background-color: #e74c3c; }
.card {
background: #fff; border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
padding: 20px; margin-bottom: 20px; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
position: relative; overflow: hidden;
}
.card:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1); }
.card-title { display: flex; align-items: center; margin-bottom: 15px; color: var(--text-primary); font-weight: 600; font-size: 18px; }
.card-title .icon { margin-right: 10px; font-size: 20px; }
.data-row { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(0, 0, 0, 0.05); transition: all 0.3s ease; }
.data-row:hover { background: rgba(0, 0, 0, 0.02); padding-left: 10px; }
.data-row:last-child { border-bottom: none; }
.data-label { color: var(--text-muted); font-weight: 500; }
.data-value { font-weight: 600; color: var(--text-primary); }
.safety-index { padding: 18px; border-radius: 10px; margin-bottom: 15px; position: relative; overflow: hidden; }
.safety-index-title { font-size: 13px; opacity: 0.8; margin-bottom: 5px; position: relative; z-index: 1; }
.safety-index-value { font-size: 40px; font-weight: 800; position: relative; z-index: 1; text-shadow: 0 2px 4px rgba(0,0,0,0.2); }
.safety-index-label { font-size: 12px; opacity: 0.9; margin-top: 5px; position: relative; z-index: 1; }
.risk-grid { display: grid; grid-template-columns: 1fr; gap: 15px; }
.risk-item {
background: #fafbfc; padding: 15px; border-radius: 10px;
border-left: 4px solid var(--glass-border);
transition: all 0.3s ease; position: relative; overflow: hidden;
}
.risk-item:hover { transform: translateX(3px); background: #f8f9fa; }
.risk-item.noise { border-left-color: var(--noise-color); }
.risk-item.crowd { border-left-color: var(--crowd-color); }
.risk-item.light { border-left-color: var(--light-color); }
.risk-item.time { border-left-color: var(--time-color); }
.risk-item.day { border-left-color: var(--day-color); }
.risk-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.risk-item-title { font-weight: 600; font-size: 14px; color: var(--text-primary); }
.risk-item-icon { font-size: 18px; opacity: 0.7; }
.risk-indicator { display: flex; align-items: center; gap: 10px; margin-top: 5px; }
.risk-bar { flex: 1; height: 8px; background: rgba(0, 0, 0, 0.05); border-radius: 4px; overflow: hidden; position: relative; }
.risk-fill { height: 100%; border-radius: 4px; transition: width 0.8s cubic-bezier(0.25, 0.8, 0.25, 1), background 0.5s ease; position: relative; overflow: hidden; }
.risk-low { background: var(--accent-green); box-shadow: 0 2px 8px rgba(39, 174, 96, 0.2); }
.risk-medium { background: var(--accent-orange); box-shadow: 0 2px 8px rgba(230, 126, 34, 0.2); }
.risk-high { background: #e74c3c; box-shadow: 0 2px 8px rgba(231, 76, 60, 0.2); }
.risk-value { min-width: 50px; text-align: right; font-weight: 600; font-size: 14px; color: var(--text-primary); transition: all 0.3s ease; }
.traffic-low { background: #d4edda; color: #155724; padding: 3px 8px; border-radius: 15px; font-weight: 600; font-size: 13px; display: inline-block; }
.traffic-medium { background: #fff3cd; color: #856404; padding: 3px 8px; border-radius: 15px; font-weight: 600; font-size: 13px; display: inline-block; }
.traffic-high { background: #f8d7da; color: #721c24; padding: 3px 8px; border-radius: 15px; font-weight: 600; font-size: 13px; display: inline-block; }
.loader { text-align: center; padding: 15px; color: var(--text-muted); font-style: italic; display: none; background: rgba(0, 0, 0, 0.02); border-radius: 8px; margin-bottom: 15px; }
.loader.active { display: block; }
.loader::before { content: 'üîÑ'; display: inline-block; animation: spin 1.2s linear infinite; margin-right: 8px; }
.btn-save { padding: 8px 16px; background: var(--accent-blue); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; margin-top: 12px; transition: all 0.3s ease; width: 100%; }
.btn-save:hover { background: #2980b9; transform: translateY(-1px); }
.btn-refresh { padding: 5px 10px; background: var(--accent-purple); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; margin-left: 8px; transition: all 0.2s ease; }
.btn-refresh:hover { background: #8e44ad; transform: scale(1.05); }
footer { margin-top: auto; padding-top: 15px; border-top: 1px solid var(--glass-border); font-size: 11px; color: var(--text-muted); text-align: center; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: #f1f1f1; }
::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: #a1a1a1; }
@media (max-width: 768px) {
body { flex-direction: column; }
#map { flex: 1; height: 50vh; min-height: 300px; }
#sidebar { flex: 1; height: 50vh; max-width: 100%; min-width: 0; }
.safety-index-value { font-size: 32px; }
}
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
</style>
</head>
<body>
<div id="ub-logo">UrbanBlind</div>
<div id="map">
<div id="map-error">
<h2>üó∫Ô∏è –ö–∞—Ä—Ç–∞ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å</h2>
<p>–í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–±–ª–µ–º–∞ —Å API –∫–ª—é—á–æ–º Yandex Maps –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ–º –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞.</p>
<p><strong>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–∞ –ö–∞–∑–∞–Ω–∏:</strong><br>55.7961, 49.1064</p>
<button onclick="location.reload()">üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É</button>
</div>
</div>
<div id="sidebar">
<div class="instructions-container">
<div class="instructions">
<h3>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é</h3>
<ul>
<li>üéØ <strong>–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –º–∞—Ä–∫–µ—Ä</strong> ‚Äî –¥–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤—è—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏</li>
<li>üñ±Ô∏è <strong>–ö–ª–∏–∫ –ø–æ –∫–∞—Ä—Ç–µ</strong> ‚Äî –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –∫ —Ç–æ—á–∫–µ</li>
<li>üìä <strong>–§–∞–∫—Ç–æ—Ä—ã —Ä–∏—Å–∫–∞</strong> ‚Äî —à—É–º, –ø–ª–æ—Ç–Ω–æ—Å—Ç—å –ª—é–¥–µ–π, –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç—å</li>
<li>üå§Ô∏è <strong>–ü–æ–≥–æ–¥–∞</strong> ‚Äî —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</li>
<li>üö¶ <strong>–ü—Ä–æ–±–∫–∏</strong> ‚Äî —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</li>
</ul>
</div>
</div>
<div class="sidebar-header">
<h1>UrbanBlind</h1>
<div class="subtitle">–§–∞–∫—Ç–æ—Ä—ã —Ä–∏—Å–∫–∞ ‚Ä¢ –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å ‚Ä¢ –ê–Ω–∞–ª–∏—Ç–∏–∫–∞</div>
<div class="api-status">
<span class="status-dot status-good" id="server-dot"></span>
<span id="server-text">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</span>
<button id="btn-force-refresh" class="btn-refresh" title="–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å">üîÑ</button>
</div>
</div>
<div id="loader" class="loader">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏ —Ä–∞—Å—á—ë—Ç —Ñ–∞–∫—Ç–æ—Ä–æ–≤ —Ä–∏—Å–∫–∞...</div>
<div id="content">
<div class="card">
<div class="card-title"><span class="icon">üõ°Ô∏è</span>–ò–Ω–¥–µ–∫—Å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</div>
<div class="safety-index" id="safety-index-card">
<div class="safety-index-title">–û–±—â–∏–π —É—Ä–æ–≤–µ–Ω—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</div>
<div class="safety-index-value" id="safety-index-value">--</div>
<div class="safety-index-label" id="safety-index-label">–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç–µ –º–∞—Ä–∫–µ—Ä –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞</div>
</div>
<div class="location-info" id="coords-display">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: 55.7961, 49.1064</div>
<button id="btn-save" class="btn-save" style="display:none;">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ—á–∫—É</button>
</div>
<div class="card">
<div class="card-title"><span class="icon">‚ö†Ô∏è</span>–§–∞–∫—Ç–æ—Ä—ã —Ä–∏—Å–∫–∞</div>
<div class="risk-grid">
<div class="risk-item noise">
<div class="risk-item-header">
<span class="risk-item-title">üîä –®—É–º –æ–∫—Ä—É–∂–∞—é—â–µ–π —Å—Ä–µ–¥—ã</span>
<span class="risk-item-icon">üì¢</span>
</div>
<div class="risk-indicator">
<div class="risk-bar"><div class="risk-fill risk-low" id="noise-bar" style="width: 0%"></div></div>
<span class="risk-value" id="noise-value">--</span>
</div>
<div style="font-size:11px;color:var(--text-muted);margin-top:5px" id="noise-desc">–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...</div>
</div>
<div class="risk-item crowd">
<div class="risk-item-header">
<span class="risk-item-title">üë• –ü–ª–æ—Ç–Ω–æ—Å—Ç—å –ª—é–¥–µ–π</span>
<span class="risk-item-icon">üö∂</span>
</div>
<div class="risk-indicator">
<div class="risk-bar"><div class="risk-fill risk-low" id="crowd-bar" style="width: 0%"></div></div>
<span class="risk-value" id="crowd-value">--</span>
</div>
<div style="font-size:11px;color:var(--text-muted);margin-top:5px" id="crowd-desc">–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...</div>
</div>
<div class="risk-item light">
<div class="risk-item-header">
<span class="risk-item-title">üí° –û—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç—å</span>
<span class="risk-item-icon">üåô</span>
</div>
<div class="risk-indicator">
<div class="risk-bar"><div class="risk-fill risk-low" id="light-bar" style="width: 0%"></div></div>
<span class="risk-value" id="light-value">--</span>
</div>
<div style="font-size:11px;color:var(--text-muted);margin-top:5px" id="light-desc">–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...</div>
</div>
<div class="risk-item time">
<div class="risk-item-header">
<span class="risk-item-title">üïê –í—Ä–µ–º—è —Å—É—Ç–æ–∫</span>
<span class="risk-item-icon">‚è∞</span>
</div>
<div class="risk-indicator">
<div class="risk-bar"><div class="risk-fill risk-low" id="time-bar" style="width: 0%"></div></div>
<span class="risk-value" id="time-value">--</span>
</div>
<div style="font-size:11px;color:var(--text-muted);margin-top:5px" id="time-desc">–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...</div>
</div>
<div class="risk-item day">
<div class="risk-item-header">
<span class="risk-item-title">üìÖ –î–µ–Ω—å –Ω–µ–¥–µ–ª–∏</span>
<span class="risk-item-icon">üìÜ</span>
</div>
<div class="risk-indicator">
<div class="risk-bar"><div class="risk-fill risk-low" id="day-bar" style="width: 0%"></div></div>
<span class="risk-value" id="day-value">--</span>
</div>
<div style="font-size:11px;color:var(--text-muted);margin-top:5px" id="day-desc">–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...</div>
</div>
</div>
</div>
<div class="card">
<div class="card-title"><span class="icon">üå§Ô∏è</span>–ü–æ–≥–æ–¥–∞</div>
<div class="data-row"><span class="data-label">–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞:</span><span class="data-value" id="w-temp">‚Äî</span></div>
<div class="data-row"><span class="data-label">–°–æ—Å—Ç–æ—è–Ω–∏–µ:</span><span class="data-value" id="w-cond">‚Äî</span></div>
<div class="data-row"><span class="data-label">–í–µ—Ç–µ—Ä:</span><span class="data-value" id="w-wind">‚Äî</span></div>
<div class="data-row"><span class="data-label">–í–ª–∞–∂–Ω–æ—Å—Ç—å:</span><span class="data-value" id="w-hum">‚Äî</span></div>
</div>
<div class="card">
<div class="card-title"><span class="icon">üöó</span>–ü—Ä–æ–±–∫–∏</div>
<div class="data-row"><span class="data-label">–£—Ä–æ–≤–µ–Ω—å:</span><span class="data-value" id="t-level">5/10</span></div>
<div class="data-row"><span class="data-label">–°–∫–æ—Ä–æ—Å—Ç—å:</span><span class="data-value" id="t-speed">25 –∫–º/—á</span></div>
<div class="data-row"><span class="data-label">–°—Ç–∞—Ç—É—Å:</span><span class="data-value" id="t-status" class="traffic-medium">–£–º–µ—Ä–µ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å</span></div>
</div>
</div>
<footer>
<p>UrbanBlind ¬© 2026 | Yandex Maps ‚Ä¢ OpenStreetMap ‚Ä¢ Open-Meteo ‚Ä¢ TomTom</p>
<p style="font-size:10px;margin-top:5px;color:var(--text-muted)">–•–∞–∫–∞—Ç–æ–Ω ¬´–£–º–Ω—ã–π –≥–æ—Ä–æ–¥¬ª ‚Äî –ê–Ω–∞–ª–∏–∑ —Ñ–∞–∫—Ç–æ—Ä–æ–≤ —Ä–∏—Å–∫–∞</p>
</footer>
</div>
<script src="https://api-maps.yandex.ru/2.1/?apikey=c2763cd1-5a14-4131-842c-2bbd60932c52&lang=ru_RU" type="text/javascript"></script>
<script>
const CONFIG = {
throttleMs: 600,
minDragDistance: 0.001,
apiBase: 'http://127.0.0.1:5000/api',
defaultCoords: [55.7961, 49.1064],
debugMode: false,
overpassUrl: 'https://overpass-api.de/api/interpreter',
openMeteoUrl: 'https://api.open-meteo.com/v1/forecast',
sunriseUrl: 'https://api.sunrise-sunset.org/json',
overpassTimeout: 25,
cacheDuration: 300000,
meersensApiKey: '0N2Odysx0NER8r240yxEY5DvbdC900HU',
meersensBaseUrl: 'https://api.meersens.com/environment/public/noise/current',
tomTomApiKey: 'yq5C1dZiEviylLPM4Z2ZSh9wzuACsoQZ',
tomTomBaseUrl: 'https://api.tomtom.com/traffic/services/4/flowSegmentData/absolute/11/json'
};

let map, placemark;
let currentCoords = [...CONFIG.defaultCoords];
let lastRequestTime = 0;
let lastRequestCoords = null;
let isDragging = false;
let pendingRequest = null;
let savedPoints = JSON.parse(localStorage.getItem('smartKazanPoints') || '[]');
let activePointId = null;
let requestCounter = 0;
let mapInitialized = false;
let apiCache = new Map();

function throttle(func, limitMs, label = '') {
return function(...args) {
const now = Date.now();
const coords = args[0];
if (lastRequestCoords) {
const dist = Math.hypot(coords[0] - lastRequestCoords[0], coords[1] - lastRequestCoords[1]);
if (dist < CONFIG.minDragDistance && now - lastRequestTime < limitMs * 2) {
return;
}
}
if (now - lastRequestTime >= limitMs) {
lastRequestTime = now;
lastRequestCoords = [...coords];
func.apply(this, args);
} else {
if (pendingRequest) clearTimeout(pendingRequest);
pendingRequest = setTimeout(() => {
lastRequestTime = Date.now();
lastRequestCoords = [...coords];
func.apply(this, args);
pendingRequest = null;
}, limitMs - (now - lastRequestTime));
}
};
}

function formatCoord(val) { return val.toFixed(4); }
function getTrafficClass(level) {
if (level > 7) return 'traffic-high';
if (level > 4) return 'traffic-medium';
return 'traffic-low';
}

function getCachedData(key) {
const cached = apiCache.get(key);
if (cached && Date.now() - cached.time < CONFIG.cacheDuration) {
return cached.data;
}
return null;
}

function setCachedData(key, data) {
apiCache.set(key, { data, time: Date.now() });
}

async function getNoiseFromMeersens(lat, lon) {
const cacheKey = `meersens:${lat.toFixed(4)},${lon.toFixed(4)}`;
const cached = getCachedData(cacheKey);
if (cached) {
cached.source = 'meersens-cached';
return cached;
}
try {
const url = `${CONFIG.meersensBaseUrl}?lat=${lat}&lng=${lon}`;
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 8000);
const response = await fetch(url, {
headers: { 'apikey': CONFIG.meersensApiKey, 'Accept': 'application/json' },
signal: controller.signal
});
clearTimeout(timeoutId);
if (!response.ok) throw new Error(`HTTP ${response.status}`);
const data = await response.json();
let noiseLevel = null;
if (data.noise) {
noiseLevel = data.noise.Lden || data.noise.Lday || data.noise.Lnight || data.noise.average;
}
if (noiseLevel !== null && noiseLevel !== undefined) {
const risk = Math.min(100, Math.max(0, ((noiseLevel - 30) / 55) * 100));
const result = {
level: Math.round(noiseLevel),
risk: Math.round(risk),
desc: getNoiseDescription(noiseLevel),
source: 'meersens',
data: data
};
setCachedData(cacheKey, result);
return result;
} else {
throw new Error('No noise data in response');
}
} catch (error) {
throw error;
}
}

function getNoiseDescription(db) {
if (db < 45) return '–¢–∏—Ö–æ: —Å–ø–æ–∫–æ–π–Ω–∞—è –∑–æ–Ω–∞, –Ω–∏–∑–∫–∏–π —Ä–∏—Å–∫ –¥–ª—è —Å–ª—É—Ö–∞';
if (db < 55) return '–£–º–µ—Ä–µ–Ω–Ω—ã–π —à—É–º: –∂–∏–ª–∞—è –∑–æ–Ω–∞, –∫–æ–º—Ñ–æ—Ä—Ç–Ω–æ';
if (db < 65) return '–ó–∞–º–µ—Ç–Ω—ã–π —à—É–º: –æ–∂–∏–≤–ª—ë–Ω–Ω–∞—è —É–ª–∏—Ü–∞, –≤–æ–∑–º–æ–∂–Ω–∞ —É—Å—Ç–∞–ª–æ—Å—Ç—å';
if (db < 75) return '–®—É–º–Ω–æ: —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∞—è –º–∞–≥–∏—Å—Ç—Ä–∞–ª—å, —Ä–∏—Å–∫ –ø—Ä–∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ–º –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏–∏';
return '–û—á–µ–Ω—å —à—É–º–Ω–æ: –∑–æ–Ω–∞ –≤—ã—Å–æ–∫–æ–≥–æ —Ä–∏—Å–∫–∞, —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∑–∞—â–∏—Ç–∞ —Å–ª—É—Ö–∞';
}

async function queryOverpass(query) {
const cacheKey = `overpass:${query.substring(0, 100)}`;
const cached = getCachedData(cacheKey);
if (cached) return cached;
try {
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 10000);
const response = await fetch(CONFIG.overpassUrl, {
method: 'POST',
body: query,
headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
signal: controller.signal
});
clearTimeout(timeoutId);
if (!response.ok) throw new Error(`HTTP ${response.status}`);
const data = await response.json();
setCachedData(cacheKey, data);
return data;
} catch (error) {
throw error;
}
}

async function getNoiseFromOSM(lat, lon) {
try {
const meersensData = await getNoiseFromMeersens(lat, lon);
return meersensData;
} catch (e) {
}
const query = `
[out:json][timeout:${CONFIG.overpassTimeout}];
(
way["highway"](around:500,${lat},${lon});
node["amenity"="bar"](around:500,${lat},${lon});
node["amenity"="restaurant"](around:500,${lat},${lon});
node["amenity"="cafe"](around:500,${lat},${lon});
node["landuse"="industrial"](around:500,${lat},${lon});
node["amenity"="fuel"](around:500,${lat},${lon});
);
out count;
`;
try {
const data = await queryOverpass(query);
const count = data.elements?.length || 0;
let level, risk, desc;
if (count > 50) { level = 85; risk = 75; desc = '–û—á–µ–Ω—å —à—É–º–Ω–æ: –º–Ω–æ–≥–æ –¥–æ—Ä–æ–≥ –∏ –∑–∞–≤–µ–¥–µ–Ω–∏–π'; }
else if (count > 25) { level = 65; risk = 55; desc = '–£–º–µ—Ä–µ–Ω–Ω—ã–π —à—É–º: —Å—Ä–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å'; }
else if (count > 10) { level = 45; risk = 35; desc = '–¢–∏—Ö–æ: –º–∞–ª–æ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —à—É–º–∞'; }
else { level = 25; risk = 20; desc = '–û—á–µ–Ω—å —Ç–∏—Ö–æ: —Å–ø–æ–∫–æ–π–Ω–∞—è –∑–æ–Ω–∞'; }
return { level, risk, desc, source: 'osm' };
} catch (e) {
return getNoiseFallback(lat, lon);
}
}

function getNoiseFallback(lat, lon) {
const centerDist = Math.hypot(lat - 55.7961, lon - 49.1064);
if (centerDist < 0.02) return { level: 75, risk: 65, desc: '–¶–µ–Ω—Ç—Ä: –≤—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å —à—É–º–∞', source: 'fallback' };
if (centerDist < 0.05) return { level: 60, risk: 45, desc: '–°–ø–∞–ª—å–Ω—ã–π —Ä–∞–π–æ–Ω: —É–º–µ—Ä–µ–Ω–Ω—ã–π —à—É–º', source: 'fallback' };
return { level: 45, risk: 30, desc: '–û–∫—Ä–∞–∏–Ω–∞: –Ω–∏–∑–∫–∏–π —É—Ä–æ–≤–µ–Ω—å —à—É–º–∞', source: 'fallback' };
}

async function getCrowdFromOSM(lat, lon) {
const query = `
[out:json][timeout:${CONFIG.overpassTimeout}];
(
node["shop"](around:300,${lat},${lon});
node["office"](around:300,${lat},${lon});
node["public_transport"](around:300,${lat},${lon});
node["amenity"="cafe"](around:300,${lat},${lon});
node["amenity"="restaurant"](around:300,${lat},${lon});
node["amenity"="bar"](around:300,${lat},${lon});
node["amenity"="fast_food"](around:300,${lat},${lon});
node["amenity"="marketplace"](around:300,${lat},${lon});
way["building"="retail"](around:300,${lat},${lon});
way["building"="commercial"](around:300,${lat},${lon});
);
out count;
`;
try {
const data = await queryOverpass(query);
const count = data.elements?.length || 0;
let level, risk, desc;
if (count > 40) { level = 85; risk = 65; desc = '–í—ã—Å–æ–∫–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: —Ç–æ—Ä–≥–æ–≤–∞—è –∑–æ–Ω–∞'; }
else if (count > 20) { level = 60; risk = 45; desc = '–°—Ä–µ–¥–Ω—è—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: —Å–º–µ—à–∞–Ω–Ω–∞—è –∑–∞—Å—Ç—Ä–æ–π–∫–∞'; }
else if (count > 5) { level = 35; risk = 25; desc = '–ù–∏–∑–∫–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: –∂–∏–ª–æ–π —Ä–∞–π–æ–Ω'; }
else { level = 15; risk = 15; desc = '–û—á–µ–Ω—å –Ω–∏–∑–∫–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: —Ç–∏—Ö–∞—è –∑–æ–Ω–∞'; }
return { level, risk, desc };
} catch (e) {
return getCrowdFallback(lat, lon);
}
}

function getCrowdFallback(lat, lon) {
const hour = new Date().getHours();
const centerDist = Math.hypot(lat - 55.7961, lon - 49.1064);
if (centerDist < 0.02 && hour >= 10 && hour < 22) return { level: 80, risk: 55, desc: '–í—ã—Å–æ–∫–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: —Ç–æ—Ä–≥–æ–≤—ã–µ –∑–æ–Ω—ã' };
if (centerDist < 0.05) return { level: 50, risk: 35, desc: '–°—Ä–µ–¥–Ω—è—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: –∂–∏–ª—ã–µ —Ä–∞–π–æ–Ω—ã' };
return { level: 25, risk: 20, desc: '–ù–∏–∑–∫–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: —Ç–∏—Ö–∏–µ –∑–æ–Ω—ã' };
}

async function getLightFromOSM(lat, lon) {
const now = new Date();
const timeInfo = await getTimeOfDayByLocation(lat, lon);
const isDaytime = timeInfo.isDaytime;
if (isDaytime) {
return { level: 95, risk: 10, desc: '–ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ (–¥–µ–Ω—å)' };
}
const query = `
[out:json][timeout:${CONFIG.overpassTimeout}];
(
node["man_made"="street_lamp"](around:200,${lat},${lon});
way["lighting"](around:200,${lat},${lon});
node["highway"="street_lamp"](around:200,${lat},${lon});
);
out count;
`;
try {
const data = await queryOverpass(query);
const count = data.elements?.length || 0;
let level, risk, desc;
if (count > 15) { level = 75; risk = 25; desc = '–•–æ—Ä–æ—à–µ–µ —É–ª–∏—á–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ'; }
else if (count > 5) { level = 50; risk = 45; desc = '–°—Ä–µ–¥–Ω–µ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ'; }
else { level = 25; risk = 70; desc = '–°–ª–∞–±–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ'; }
return { level, risk, desc };
} catch (e) {
return getLightFallback(lat, lon);
}
}

function getLightFallback(lat, lon) {
const hour = new Date().getHours();
if (hour >= 7 && hour < 21) return { level: 95, risk: 10, desc: '–î–µ–Ω—å' };
return { level: 25, risk: 70, desc: '–ù–æ—á—å' };
}

async function getSunriseSunset(lat, lon) {
const cacheKey = `sunrise:${lat.toFixed(4)},${lon.toFixed(4)}`;
const cached = getCachedData(cacheKey);
if (cached) return cached;
try {
const url = `https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&date=today&formatted=0`;
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);
const response = await fetch(url, { signal: controller.signal });
clearTimeout(timeoutId);
if (!response.ok) throw new Error(`HTTP ${response.status}`);
const data = await response.json();
if (!data.results || !data.results.sunrise) throw new Error('Invalid response format');
const result = {
sunrise: new Date(data.results.sunrise),
sunset: new Date(data.results.sunset),
solar_noon: new Date(data.results.solar_noon),
civil_twilight_begin: new Date(data.results.civil_twilight_begin),
civil_twilight_end: new Date(data.results.civil_twilight_end)
};
setCachedData(cacheKey, result);
return result;
} catch (error) {
return null;
}
}

async function getTimeOfDayByLocation(lat, lon) {
const now = new Date();
const sunData = await getSunriseSunset(lat, lon);
if (!sunData) {
const hour = now.getHours();
return {
timeOfDay: hour >= 6 && hour < 12 ? '–£—Ç—Ä–æ' : hour >= 12 && hour < 18 ? '–î–µ–Ω—å' : hour >= 18 && hour < 23 ? '–í–µ—á–µ—Ä' : '–ù–æ—á—å',
isDaytime: hour >= 6 && hour < 22,
description: '–õ–æ–∫–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è'
};
}
const isDaytime = now >= sunData.sunrise && now < sunData.sunset;
let timeOfDay, description;
if (now < sunData.sunrise) { timeOfDay = '–ù–æ—á—å'; description = '–¢–µ–º–Ω–æ, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å'; }
else if (now < new Date(sunData.sunrise.getTime() + 2 * 60 * 60 * 1000)) { timeOfDay = '–£—Ç—Ä–æ'; description = '–ê–∫—Ç–∏–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ, —Ö–æ—Ä–æ—à–∏–π –æ–±–∑–æ—Ä'; }
else if (now < sunData.sunset) { timeOfDay = '–î–µ–Ω—å'; description = '–í—ã—Å–æ–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å, —Ö–æ—Ä–æ—à–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å'; }
else if (now < sunData.civil_twilight_end) { timeOfDay = '–í–µ—á–µ—Ä'; description = '–£–º–µ—Ä–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å, –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–Ω–∏–∂–∞–µ—Ç—Å—è'; }
else { timeOfDay = '–ù–æ—á—å'; description = '–¢–µ–º–Ω–æ, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å'; }
return { timeOfDay, isDaytime, description };
}

async function getWeatherFromOpenMeteo(lat, lon) {
const cacheKey = `weather:${lat.toFixed(2)},${lon.toFixed(2)}`;
const cached = getCachedData(cacheKey);
if (cached) {
return cached;
}
try {
const url = `${CONFIG.openMeteoUrl}?` +
`latitude=${lat}&` +
`longitude=${lon}&` +
`current_weather=true&` +
`hourly=relative_humidity_2m&` +
`timezone=auto&` +
`forecast_days=1`;

const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 10000);
const response = await fetch(url, {
method: 'GET',
headers: { 'Accept': 'application/json' },
signal: controller.signal
});
clearTimeout(timeoutId);

if (!response.ok) throw new Error(`HTTP ${response.status}`);
const data = await response.json();

if (!data.current_weather) throw new Error('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Ç–µ–∫—É—â–µ–π –ø–æ–≥–æ–¥–µ');

let humidity = 0;
if (data.hourly && data.hourly.time && data.hourly.relative_humidity_2m) {
const now = new Date();
const currentHourStr = now.toISOString().slice(0, 13); 
const index = data.hourly.time.findIndex(t => t.startsWith(currentHourStr));

if (index !== -1 && data.hourly.relative_humidity_2m[index] !== undefined) {
humidity = data.hourly.relative_humidity_2m[index];
} else {
humidity = data.hourly.relative_humidity_2m[0] || 0;
}
}

const weather = {
temp: data.current_weather.temperature ?? 0,
wind: `${data.current_weather.windspeed ?? 0} –º/—Å`,
windDirection: getWindDirection(data.current_weather.winddirection),
humidity: humidity,
condition: getWeatherCondition(data.current_weather.weathercode),
weatherCode: data.current_weather.weathercode
};
setCachedData(cacheKey, weather);
return weather;
} catch (error) {
return {
temp: 0, wind: '‚Äî', windDirection: '‚Äî', humidity: 0,
condition: '–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ', weatherCode: null, error: error.message
};
}
}

function getWindDirection(degrees) {
if (degrees === undefined || degrees === null) return '‚Äî';
const directions = ['–°', '–°–í', '–í', '–Æ–í', '–Æ', '–Æ–ó', '–ó', '–°–ó'];
const index = Math.round(degrees / 45) % 8;
return directions[index];
}

function getWeatherCondition(code) {
const conditions = {
0: '‚òÄÔ∏è –Ø—Å–Ω–æ', 1: 'üå§Ô∏è –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–µ–Ω–Ω–æ —è—Å–Ω–æ', 2: '‚õÖ –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–±–ª–∞—á–Ω–æ—Å—Ç—å',
3: '‚òÅÔ∏è –ü–∞—Å–º—É—Ä–Ω–æ', 45: 'üå´Ô∏è –¢—É–º–∞–Ω', 48: '‚ùÑÔ∏è –ò–Ω–µ–π',
51: 'üíß –ú–æ—Ä–æ—Å—å', 53: 'üíß –ú–æ—Ä–æ—Å—å', 55: 'üíß –ú–æ—Ä–æ—Å—å',
61: 'üåßÔ∏è –î–æ–∂–¥—å', 63: 'üåßÔ∏è –î–æ–∂–¥—å', 65: 'üåßÔ∏è –°–∏–ª—å–Ω—ã–π –¥–æ–∂–¥—å',
71: '‚ùÑÔ∏è –°–Ω–µ–≥', 73: '‚ùÑÔ∏è –°–Ω–µ–≥', 75: '‚ùÑÔ∏è –°–∏–ª—å–Ω—ã–π —Å–Ω–µ–≥',
80: 'üå¶Ô∏è –õ–∏–≤–µ–Ω—å', 81: 'üå¶Ô∏è –õ–∏–≤–µ–Ω—å', 82: 'üå¶Ô∏è –°–∏–ª—å–Ω—ã–π –ª–∏–≤–µ–Ω—å',
95: '‚õàÔ∏è –ì—Ä–æ–∑–∞', 96: '‚õàÔ∏è –ì—Ä–æ–∑–∞ —Å –≥—Ä–∞–¥–æ–º', 99: '‚õàÔ∏è –°–∏–ª—å–Ω–∞—è –≥—Ä–æ–∑–∞ —Å –≥—Ä–∞–¥–æ–º'
};
return conditions[code] || '‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
}

async function getTrafficFromTomTom(lat, lon) {
const cacheKey = `tomtom:${lat.toFixed(4)},${lon.toFixed(4)}`;
const cached = getCachedData(cacheKey);
if (cached) return cached;
try {
const url = `${CONFIG.tomTomBaseUrl}/${CONFIG.tomTomApiKey}?point=${lat},${lon}`;
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 10000);
const response = await fetch(url, {
headers: { 'Accept': 'application/json' },
signal: controller.signal
});
clearTimeout(timeoutId);
if (!response.ok) throw new Error(`HTTP ${response.status}`);
const data = await response.json();
if (!data.flowSegmentData || !data.flowSegmentData.currentSpeed) {
throw new Error('Invalid response format');
}
const { currentSpeed, freeFlowSpeed, roadClosure } = data.flowSegmentData;
let trafficLevel = 0;
if (roadClosure) {
trafficLevel = 10;
} else if (freeFlowSpeed > 0) {
const speedRatio = currentSpeed / freeFlowSpeed;
trafficLevel = Math.min(10, Math.round((1 - speedRatio) * 10));
}
let status, speedAvg;
if (roadClosure) {
status = '–î–æ—Ä–æ–≥–∞ –∑–∞–∫—Ä—ã—Ç–∞';
speedAvg = '0 –∫–º/—á';
} else if (trafficLevel > 7) {
status = '–í—ã—Å–æ–∫–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å';
speedAvg = `${Math.min(20, currentSpeed)} –∫–º/—á`;
} else if (trafficLevel > 4) {
status = '–£–º–µ—Ä–µ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å';
speedAvg = `${Math.min(30, currentSpeed)} –∫–º/—á`;
} else {
status = '–ù–∏–∑–∫–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å';
speedAvg = `${Math.min(50, currentSpeed)} –∫–º/—á`;
}
const trafficData = {
level: trafficLevel,
status: status,
speed_avg: speedAvg,
current_speed: currentSpeed,
free_flow_speed: freeFlowSpeed,
road_closure: roadClosure
};
setCachedData(cacheKey, trafficData);
return trafficData;
} catch (error) {
return getTrafficFallback(lat, lon);
}
}

function getTrafficFallback(lat, lon) {
const hour = new Date().getHours();
const day = new Date().getDay();
let trafficLevel;
if (day === 0 || day === 6) {
trafficLevel = 3;
} else {
if ((hour >= 7 && hour <= 9) || (hour >= 17 && hour <= 19)) {
trafficLevel = 8;
} else if (hour >= 10 && hour <= 16) {
trafficLevel = 5;
} else {
trafficLevel = 4;
}
}
let status, speedAvg;
if (trafficLevel > 7) { status = '–í—ã—Å–æ–∫–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å'; speedAvg = '10-20 –∫–º/—á'; }
else if (trafficLevel > 4) { status = '–£–º–µ—Ä–µ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å'; speedAvg = '20-30 –∫–º/—á'; }
else { status = '–ù–∏–∑–∫–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å'; speedAvg = '30-40 –∫–º/—á'; }
return { level: trafficLevel, status: status, speed_avg: speedAvg };
}

async function calculateRiskFactors(coords, serverData = null) {
const [lat, lon] = coords;
const now = new Date();
const day = now.getDay();
const timeInfo = await getTimeOfDayByLocation(lat, lon);
const timeOfDay = timeInfo.timeOfDay;
const timeDesc = timeInfo.description;
let timeRisk;
if (timeOfDay === '–ì–ª—É–±–æ–∫–∞—è –Ω–æ—á—å' || timeOfDay === '–ù–æ—á—å') { timeRisk = 75; }
else if (timeOfDay === '–ó–∞–∫–∞—Ç' || timeOfDay === '–í–µ—á–µ—Ä') { timeRisk = 60; }
else if (timeOfDay === '–£—Ç—Ä–æ' || timeOfDay === '–†–∞—Å—Å–≤–µ—Ç') { timeRisk = 30; }
else { timeRisk = 40; }
const dayNames = ['–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ', '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞'];
const dayName = dayNames[day];
let dayRisk, dayDesc;
if (day === 0 || day === 6) { dayRisk = 35; dayDesc = '–í—ã—Ö–æ–¥–Ω–æ–π: –º–µ–Ω—å—à–µ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞, –±–æ–ª—å—à–µ –ø–µ—à–µ—Ö–æ–¥–æ–≤'; }
else if (day === 5) { dayRisk = 70; dayDesc = '–ü—è—Ç–Ω–∏—Ü–∞: –≤–µ—á–µ—Ä–Ω–∏–µ –ø—Ä–æ–±–∫–∏, —É—Å—Ç–∞–ª–æ—Å—Ç—å –ø–æ—Å–ª–µ –Ω–µ–¥–µ–ª–∏'; }
else { dayRisk = 55; dayDesc = '–ë—É–¥–Ω–∏–π –¥–µ–Ω—å: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞'; }
const [noiseData, crowdData, lightData, weatherData, trafficData] = await Promise.allSettled([
getNoiseFromOSM(lat, lon),
getCrowdFromOSM(lat, lon),
getLightFromOSM(lat, lon),
getWeatherFromOpenMeteo(lat, lon),
getTrafficFromTomTom(lat, lon)
]);
let noise = noiseData.status === 'fulfilled' ? noiseData.value : getNoiseFallback(lat, lon);
let crowd = crowdData.status === 'fulfilled' ? crowdData.value : getCrowdFallback(lat, lon);
let light = lightData.status === 'fulfilled' ? lightData.value : getLightFallback(lat, lon);
let weather = weatherData.status === 'fulfilled' ? weatherData.value : null;
let traffic = trafficData.status === 'fulfilled' ? trafficData.value : getTrafficFallback(lat, lon);
if (serverData?.risks) {
const r = serverData.risks;
if (r.noise) { noise = { ...noise, ...r.noise }; }
if (r.crowd) { crowd = { ...crowd, ...r.crowd }; }
if (r.light) { light = { ...light, ...r.light }; }
if (r.traffic) { traffic = { ...traffic, ...r.traffic }; }
}
const trafficRisk = traffic.level * 10;
const avgRisk = (noise.risk + crowd.risk + light.risk + timeRisk + dayRisk + trafficRisk) / 6;
const safetyIndex = Math.round(100 - avgRisk);
return {
noise, crowd, light,
time: { value: timeOfDay, risk: timeRisk, desc: timeDesc },
day: { value: dayName, risk: dayRisk, desc: dayDesc },
traffic, weather, safetyIndex,
timestamp: new Date().toLocaleString('ru')
};
}

function getRiskClass(risk) {
if (risk < 40) return 'risk-low';
if (risk < 70) return 'risk-medium';
return 'risk-high';
}

function getSafetyColor(index) {
if (index >= 70) return '#27ae60';
if (index >= 40) return '#f39c12';
return '#e74c3c';
}

function getSafetyLabel(index) {
if (index >= 80) return 'üü¢ –û—á–µ–Ω—å –±–µ–∑–æ–ø–∞—Å–Ω–æ';
if (index >= 60) return 'üü° –ë–µ–∑–æ–ø–∞—Å–Ω–æ';
if (index >= 40) return 'üü† –£–º–µ—Ä–µ–Ω–Ω—ã–π —Ä–∏—Å–∫';
if (index >= 20) return 'üî¥ –ü–æ–≤—ã—à–µ–Ω–Ω—ã–π —Ä–∏—Å–∫';
return '‚ö´ –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫';
}

ymaps.ready(init);

function init() {
try {
map = new ymaps.Map('map', {
center: CONFIG.defaultCoords,
zoom: 13,
controls: ['zoomControl', 'fullscreenControl', 'geolocationControl']
});
try {
new ymaps.layer.TrafficLayer({ trafficProvider: 'yandex#actual' }).setMap(map);
} catch(e) {}
createPlacemark(CONFIG.defaultCoords);
mapInitialized = true;
map.events.add('click', function(e) {
const coords = e.get('coords');
movePlacemark(coords, true);
});
checkServer();
requestWeatherData(CONFIG.defaultCoords, true);
document.getElementById('btn-force-refresh').addEventListener('click', forceRefresh);
document.getElementById('btn-save').addEventListener('click', saveCurrentPoint);
} catch (error) {
showMapError(error);
}
}

function showMapError(error) {
const errorEl = document.getElementById('map-error');
errorEl.classList.add('visible');
}

function createPlacemark(coords) {
if (placemark) map.geoObjects.remove(placemark);
placemark = new ymaps.Placemark(coords, {
hintContent: 'üéØ –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ä–∏—Å–∫–æ–≤',
balloonContentHeader: '–í—ã–±—Ä–∞–Ω–Ω–∞—è —Ç–æ—á–∫–∞',
balloonContentBody: '–§–∞–∫—Ç–æ—Ä—ã —Ä–∏—Å–∫–∞ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏'
}, {
preset: 'islands#redStretchyIcon',
draggable: true,
iconColor: '#e74c3c'
});
placemark.events.add('dragstart', () => {
isDragging = true;
});
placemark.events.add('drag', (e) => {
const coords = placemark.geometry.getCoordinates();
updateCoordsDisplay(coords);
currentCoords = coords;
throttledRequest(coords);
});
placemark.events.add('dragend', () => {
isDragging = false;
const coords = placemark.geometry.getCoordinates();
requestWeatherData(coords, true);
});
map.geoObjects.add(placemark);
}

function movePlacemark(coords, forceUpdate = false) {
if (placemark) {
placemark.geometry.setCoordinates(coords);
} else {
createPlacemark(coords);
return;
}
map.panTo(coords, { duration: 250, flying: true });
updateCoordsDisplay(coords);
currentCoords = coords;
if (forceUpdate) {
requestWeatherData(coords, true);
} else {
throttledRequest(coords);
}
}

function updateCoordsDisplay(coords) {
document.getElementById('coords-display').textContent =
`–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: ${formatCoord(coords[0])}, ${formatCoord(coords[1])}`;
}

const throttledRequest = throttle(
(coords) => requestWeatherData(coords, false),
CONFIG.throttleMs,
'DRAG'
);

async function requestWeatherData(coords, force = false) {
requestCounter++;
if (!force && lastRequestCoords &&
Math.abs(coords[0] - lastRequestCoords[0]) < 0.0001 &&
Math.abs(coords[1] - lastRequestCoords[1]) < 0.0001) {
return;
}
showLoader(true);
try {
const timestamp = Date.now();
const response = await fetch(`${CONFIG.apiBase}/analyze?t=${timestamp}`, {
method: 'POST',
headers: { 'Content-Type': 'application/json', 'Cache-Control': 'no-cache' },
body: JSON.stringify({ lat: coords[0], lon: coords[1], timestamp: timestamp }),
timeout: 5000
});
let data;
if (response.ok) {
data = await response.json();
} else {
data = { now: {} };
}
const risks = await calculateRiskFactors(coords, data);
data.risks = risks;
renderData(data, coords);
updateStatus('ok');
} catch (err) {
const risks = await calculateRiskFactors(coords, { now: {} });
renderData({ now: {}, risks }, coords);
updateStatus('warning', 'API –¥–∞–Ω–Ω—ã–µ');
} finally {
showLoader(false);
}
}

function forceRefresh() {
apiCache.clear();
requestWeatherData(currentCoords, true);
}

function renderData(data, coords) {
const w = data?.risks?.weather || data?.now?.weather || {};
const risks = data?.risks;
const safetyIndex = risks?.safetyIndex || 0;
const safetyEl = document.getElementById('safety-index-value');
const safetyLabel = document.getElementById('safety-index-label');
const safetyCard = document.getElementById('safety-index-card');
safetyEl.textContent = safetyIndex;
safetyEl.style.color = 'white';
const safetyColor = getSafetyColor(safetyIndex);
let darkColor;
if (safetyIndex >= 70) { darkColor = '#1e8449'; }
else if (safetyIndex >= 40) { darkColor = '#d35400'; }
else { darkColor = '#c0392b'; }
safetyLabel.textContent = getSafetyLabel(safetyIndex);
safetyCard.style.background = `linear-gradient(135deg, ${safetyColor} 0%, ${darkColor} 100%)`;
safetyCard.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.15)';

updateRiskItem('noise', risks?.noise?.level, risks?.noise?.risk, risks?.noise?.desc);
updateRiskItem('crowd', risks?.crowd?.level, risks?.crowd?.risk, risks?.crowd?.desc);
updateRiskItem('light', risks?.light?.level, risks?.light?.risk, risks?.light?.desc);
updateRiskItem('time', null, risks?.time?.risk, risks?.time?.desc, risks?.time?.value);
updateRiskItem('day', null, risks?.day?.risk, risks?.day?.desc, risks?.day?.value);

const tempEl = document.getElementById('w-temp');
const condEl = document.getElementById('w-cond');
const windEl = document.getElementById('w-wind');
const humEl = document.getElementById('w-hum');
if (tempEl) tempEl.textContent = w.temp != null ? `${w.temp}¬∞C` : '‚Äî';
if (condEl) condEl.textContent = w.condition || '‚Äî';
if (windEl) windEl.textContent = w.wind || '‚Äî';
if (humEl) humEl.textContent = w.humidity != null ? `${w.humidity}%` : '‚Äî';

const t = risks?.traffic || { level: 5, status: '–£–º–µ—Ä–µ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å', speed_avg: '25 –∫–º/—á' };
const levelEl = document.getElementById('t-level');
const speedEl = document.getElementById('t-speed');
const statusEl = document.getElementById('t-status');
const level = t.level ?? '‚Äî';
const status = t.status || '‚Äî';
const speed = t.speed_avg || '‚Äî';
if (levelEl) levelEl.textContent = level !== '‚Äî' ? `${level}/10` : '‚Äî';
if (speedEl) speedEl.textContent = speed;
if (statusEl) {
statusEl.textContent = status;
statusEl.className = 'data-value ' + (level !== '‚Äî' ? getTrafficClass(level) : '');
}
document.getElementById('btn-save').style.display = 'inline-block';
}

function updateRiskItem(type, level, risk, desc, valueOverride = null) {
const bar = document.getElementById(`${type}-bar`);
const value = document.getElementById(`${type}-value`);
const description = document.getElementById(`${type}-desc`);
if (!bar || !value) return;
const riskClass = getRiskClass(risk);
bar.className = `risk-fill ${riskClass}`;
setTimeout(() => { bar.style.width = `${risk}%`; }, 100);
if (valueOverride !== null) {
value.textContent = valueOverride;
} else if (level !== null) {
value.textContent = `${level}%`;
} else {
value.textContent = `${risk}%`;
}
if (description) description.textContent = desc;
}

function showLoader(show) {
const loader = document.getElementById('loader');
const content = document.getElementById('content');
loader.classList.toggle('active', show);
content.style.opacity = show ? '0.7' : '1';
content.style.pointerEvents = show ? 'none' : 'auto';
}

function updateStatus(state, text = '') {
const dot = document.getElementById('server-dot');
const txt = document.getElementById('server-text');
dot.className = 'status-dot ' + (state === 'ok' ? 'status-good' : state === 'error' ? 'status-error' : 'status-warning');
txt.textContent = text || (state === 'ok' ? '–û–Ω–ª–∞–π–Ω' : state === 'error' ? '–û—à–∏–±–∫–∞' : '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
}

function saveCurrentPoint() {
const name = prompt('üìå –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–æ—á–∫–∏:', `–¢–æ—á–∫–∞ #${savedPoints.length + 1}`);
if (!name?.trim()) return;
const point = {
id: Date.now(),
name: name.trim(),
coords: [...currentCoords],
data: null,
created: new Date().toISOString(),
updated: null
};
savedPoints.unshift(point);
savePointsToStorage();
alert('‚úÖ –¢–æ—á–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!');
}

function savePointsToStorage() {
try { localStorage.setItem('smartKazanPoints', JSON.stringify(savedPoints)); }
catch(e) {}
}

async function checkServer() {
try {
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 3000);
const r = await fetch(`${CONFIG.apiBase}/health`, { signal: controller.signal });
clearTimeout(timeoutId);
if (r.ok) updateStatus('ok', '–û–Ω–ª–∞–π–Ω');
else throw new Error('HTTP ' + r.status);
} catch {
updateStatus('warning', 'API –¥–∞–Ω–Ω—ã–µ');
}
}

setInterval(checkServer, 30000);
setTimeout(() => {
if (!mapInitialized) {
showMapError(new Error('Timeout'));
}
}, 5000);
</script>
</body>
</html>
