<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>UrbanBlind - –ê–Ω–∞–ª–∏–∑ —Ä–∏—Å–∫–æ–≤ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ (–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π)</title>
<style>
/* –°—Ç–∏–ª–∏ –æ—Å—Ç–∞–ª–∏—Å—å –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
* { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
:root {
--glass-bg: rgba(255, 255, 255, 0.85);
--glass-border: rgba(0, 0, 0, 0.08);
--glass-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
--glass-blur: blur(12px);
--primary-color: #34495e;
--secondary-color: #2c3e50;
--accent-blue: #3498db;
--accent-orange: #e67e22;
--accent-purple: #9b59b6;
--accent-green: #27ae60;
--text-primary: #2c3e50;
--text-secondary: #7f8c8d;
--text-muted: #95a5a6;
--noise-color: #f39c12;
--crowd-color: #9b59b6;
--light-color: #3498db;
--time-color: #1abc9c;
--day-color: #e67e22;
}
body { display: flex; height: 100vh; overflow: hidden; background: linear-gradient(135deg, #f5f7fa 0%, #e4e7eb 100%); width: 100vw; }
#ub-logo {
position: fixed; top: 5px; left: 40px; font-size: 28px; font-weight: 800;
color: var(--secondary-color); z-index: 100; text-shadow: 0 2px 4px rgba(0,0,0,0.05);
letter-spacing: -1px; background: #ffffff; border-radius: 12px;
padding: 5px 16px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
border: 1px solid rgba(0, 0, 0, 0.08); transition: all 0.3s ease;
}
#ub-logo:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15); }
#map { flex: 2; height: 100%; min-width: 0; position: relative; background: #e8eaed; }
#map-error {
position: absolute; top: 0; left: 0; right: 0; bottom: 0;
background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
color: white; display: none; flex-direction: column;
align-items: center; justify-content: center; text-align: center;
padding: 20px; z-index: 1000; animation: fadeIn 0.5s ease;
}
#map-error.visible { display: flex; }
#map-error h2 { margin-bottom: 15px; font-size: 24px; }
#map-error p { margin-bottom: 20px; max-width: 400px; line-height: 1.6; }
#map-error button {
padding: 12px 24px; background: rgba(255, 255, 255, 0.15);
color: white; border: 1px solid rgba(255, 255, 255, 0.3);
border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px;
transition: all 0.3s ease;
}
#map-error button:hover { background: rgba(255, 255, 255, 0.25); transform: translateY(-2px); }
#sidebar {
flex: 1; background: var(--glass-bg); backdrop-filter: var(--glass-blur);
-webkit-backdrop-filter: var(--glass-blur); padding: 20px;
overflow-y: auto; box-shadow: var(--glass-shadow);
max-width: 500px; display: flex; flex-direction: column;
z-index: 10; min-width: 350px; position: relative;
}
.instructions-container {
position: sticky; top: 0; z-index: 100; background: var(--glass-bg);
backdrop-filter: var(--glass-blur); -webkit-backdrop-filter: var(--glass-blur);
border-radius: 12px; margin: -20px -20px 20px -20px;
padding: 15px 20px; box-shadow: var(--glass-shadow);
}
.instructions {
background: rgba(238, 247, 255, 0.7); border-left: 4px solid var(--accent-blue);
padding: 12px; border-radius: 0 4px 4px 0; font-size: 13px; color: var(--text-primary);
}
.instructions h3 { font-weight: 600; margin-bottom: 8px; color: var(--secondary-color); display: flex; align-items: center; gap: 8px; }
.instructions ul { padding-left: 20px; }
.instructions li { margin-bottom: 5px; line-height: 1.4; }
.sidebar-header {
margin-bottom: 20px; padding-bottom: 15px;
border-bottom: 1px solid var(--glass-border);
position: sticky; top: 0; background: var(--glass-bg); z-index: 100;
}
h1 { font-size: 20px; color: var(--secondary-color); margin-bottom: 5px; font-weight: 600; }
.subtitle { color: var(--text-muted); font-size: 12px; font-weight: 500; }
.api-status {
display: flex; align-items: center; font-size: 11px;
color: var(--text-muted); margin-top: 12px; flex-wrap: wrap;
gap: 8px; background: rgba(0, 0, 0, 0.03); padding: 8px 12px; border-radius: 8px;
}
.status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 4px; }
.status-good { background-color: var(--accent-green); }
.status-warning { background-color: var(--accent-orange); }
.status-error { background-color: #e74c3c; }
.card {
background: #fff; border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
padding: 20px; margin-bottom: 20px; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
position: relative; overflow: hidden;
}
.card:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1); }
.card-title { display: flex; align-items: center; margin-bottom: 15px; color: var(--text-primary); font-weight: 600; font-size: 18px; }
.card-title .icon { margin-right: 10px; font-size: 20px; }
.data-row { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(0, 0, 0, 0.05); transition: all 0.3s ease; }
.data-row:hover { background: rgba(0, 0, 0, 0.02); padding-left: 10px; }
.data-row:last-child { border-bottom: none; }
.data-label { color: var(--text-muted); font-weight: 500; }
.data-value { font-weight: 600; color: var(--text-primary); }
.safety-index { padding: 18px; border-radius: 10px; margin-bottom: 15px; position: relative; overflow: hidden; }
.safety-index-title { font-size: 13px; opacity: 0.8; margin-bottom: 5px; position: relative; z-index: 1; }
.safety-index-value { font-size: 40px; font-weight: 800; position: relative; z-index: 1; text-shadow: 0 2px 4px rgba(0,0,0,0.2); }
.safety-index-label { font-size: 12px; opacity: 0.9; margin-top: 5px; position: relative; z-index: 1; }
.risk-grid { display: grid; grid-template-columns: 1fr; gap: 15px; }
.risk-item {
background: #fafbfc; padding: 15px; border-radius: 10px;
border-left: 4px solid var(--glass-border);
transition: all 0.3s ease; position: relative; overflow: hidden;
}
.risk-item:hover { transform: translateX(3px); background: #f8f9fa; }
.risk-item.noise { border-left-color: var(--noise-color); }
.risk-item.crowd { border-left-color: var(--crowd-color); }
.risk-item.light { border-left-color: var(--light-color); }
.risk-item.time { border-left-color: var(--time-color); }
.risk-item.day { border-left-color: var(--day-color); }
.risk-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.risk-item-title { font-weight: 600; font-size: 14px; color: var(--text-primary); }
.risk-item-icon { font-size: 18px; opacity: 0.7; }
.risk-indicator { display: flex; align-items: center; gap: 10px; margin-top: 5px; }
.risk-bar { flex: 1; height: 8px; background: rgba(0, 0, 0, 0.05); border-radius: 4px; overflow: hidden; position: relative; }
.risk-fill { height: 100%; border-radius: 4px; transition: width 0.8s cubic-bezier(0.25, 0.8, 0.25, 1), background 0.5s ease; position: relative; overflow: hidden; }
.risk-low { background: var(--accent-green); box-shadow: 0 2px 8px rgba(39, 174, 96, 0.2); }
.risk-medium { background: var(--accent-orange); box-shadow: 0 2px 8px rgba(230, 126, 34, 0.2); }
.risk-high { background: #e74c3c; box-shadow: 0 2px 8px rgba(231, 76, 60, 0.2); }
.risk-value { min-width: 50px; text-align: right; font-weight: 600; font-size: 14px; color: var(--text-primary); transition: all 0.3s ease; }
.traffic-low { background: #d4edda; color: #155724; padding: 3px 8px; border-radius: 15px; font-weight: 600; font-size: 13px; display: inline-block; }
.traffic-medium { background: #fff3cd; color: #856404; padding: 3px 8px; border-radius: 15px; font-weight: 600; font-size: 13px; display: inline-block; }
.traffic-high { background: #f8d7da; color: #721c24; padding: 3px 8px; border-radius: 15px; font-weight: 600; font-size: 13px; display: inline-block; }
.loader { text-align: center; padding: 15px; color: var(--text-muted); font-style: italic; display: none; background: rgba(0, 0, 0, 0.02); border-radius: 8px; margin-bottom: 15px; }
.loader.active { display: block; }
.loader::before { content: 'üîÑ'; display: inline-block; animation: spin 1.2s linear infinite; margin-right: 8px; }
.btn-save { padding: 8px 16px; background: var(--accent-blue); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; margin-top: 12px; transition: all 0.3s ease; width: 100%; }
.btn-save:hover { background: #2980b9; transform: translateY(-1px); }
.btn-refresh { padding: 5px 10px; background: var(--accent-purple); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; margin-left: 8px; transition: all 0.2s ease; }
.btn-refresh:hover { background: #8e44ad; transform: scale(1.05); }
footer { margin-top: auto; padding-top: 15px; border-top: 1px solid var(--glass-border); font-size: 11px; color: var(--text-muted); text-align: center; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: #f1f1f1; }
::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: #a1a1a1; }
@media (max-width: 768px) {
body { flex-direction: column; }
#map { flex: 1; height: 50vh; min-height: 300px; }
#sidebar { flex: 1; height: 50vh; max-width: 100%; min-width: 0; }
.safety-index-value { font-size: 32px; }
}
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
</style>
</head>
<body>
<div id="ub-logo">UrbanBlind</div>
<div id="map">
<div id="map-error">
<h2>üó∫Ô∏è –ö–∞—Ä—Ç–∞ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å</h2>
<p>–í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–±–ª–µ–º–∞ —Å API –∫–ª—é—á–æ–º Yandex Maps –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ–º –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞.</p>
<p><strong>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–∞ –ö–∞–∑–∞–Ω–∏:</strong><br>55.7961, 49.1064</p>
<button onclick="location.reload()">üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É</button>
</div>
</div>
<div id="sidebar">
<div class="instructions-container">
<div class="instructions">
<h3>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é</h3>
<ul>
<li>üéØ <strong>–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –º–∞—Ä–∫–µ—Ä</strong> ‚Äî –¥–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤—è—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏</li>
<li>üñ±Ô∏è <strong>–ö–ª–∏–∫ –ø–æ –∫–∞—Ä—Ç–µ</strong> ‚Äî –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –∫ —Ç–æ—á–∫–µ</li>
<li>üìä <strong>–§–∞–∫—Ç–æ—Ä—ã —Ä–∏—Å–∫–∞</strong> ‚Äî —à—É–º, –ø–ª–æ—Ç–Ω–æ—Å—Ç—å –ª—é–¥–µ–π, –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç—å</li>
<li>üå§Ô∏è <strong>–ü–æ–≥–æ–¥–∞</strong> ‚Äî —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</li>
<li>üö¶ <strong>–ü—Ä–æ–±–∫–∏</strong> ‚Äî —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</li>
</ul>
</div>
</div>
<div class="sidebar-header">
<h1>UrbanBlind</h1>
<div class="subtitle">–§–∞–∫—Ç–æ—Ä—ã —Ä–∏—Å–∫–∞ ‚Ä¢ –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å ‚Ä¢ –ê–Ω–∞–ª–∏—Ç–∏–∫–∞</div>
<div class="api-status">
<span class="status-dot status-good" id="server-dot"></span>
<span id="server-text">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</span>
<button id="btn-force-refresh" class="btn-refresh" title="–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å">üîÑ</button>
</div>
</div>
<div id="loader" class="loader">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏ —Ä–∞—Å—á—ë—Ç —Ñ–∞–∫—Ç–æ—Ä–æ–≤ —Ä–∏—Å–∫–∞...</div>
<div id="content">
<div class="card">
<div class="card-title"><span class="icon">üõ°Ô∏è</span>–ò–Ω–¥–µ–∫—Å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</div>
<div class="safety-index" id="safety-index-card">
<div class="safety-index-title">–û–±—â–∏–π —É—Ä–æ–≤–µ–Ω—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</div>
<div class="safety-index-value" id="safety-index-value">--</div>
<div class="safety-index-label" id="safety-index-label">–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç–µ –º–∞—Ä–∫–µ—Ä –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞</div>
</div>
<div class="location-info" id="coords-display">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: 55.7961, 49.1064</div>
<button id="btn-save" class="btn-save" style="display:none;">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ—á–∫—É</button>
</div>
<div class="card">
<div class="card-title"><span class="icon">‚ö†Ô∏è</span>–§–∞–∫—Ç–æ—Ä—ã —Ä–∏—Å–∫–∞</div>
<div class="risk-grid">
<div class="risk-item noise">
<div class="risk-item-header">
<span class="risk-item-title">üîä –®—É–º –æ–∫—Ä—É–∂–∞—é—â–µ–π —Å—Ä–µ–¥—ã</span>
<span class="risk-item-icon">üì¢</span>
</div>
<div class="risk-indicator">
<div class="risk-bar"><div class="risk-fill risk-low" id="noise-bar" style="width: 0%"></div></div>
<span class="risk-value" id="noise-value">--</span>
</div>
<div style="font-size:11px;color:var(--text-muted);margin-top:5px" id="noise-desc">–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...</div>
</div>
<div class="risk-item crowd">
<div class="risk-item-header">
<span class="risk-item-title">üë• –ü–ª–æ—Ç–Ω–æ—Å—Ç—å –ª—é–¥–µ–π</span>
<span class="risk-item-icon">üö∂</span>
</div>
<div class="risk-indicator">
<div class="risk-bar"><div class="risk-fill risk-low" id="crowd-bar" style="width: 0%"></div></div>
<span class="risk-value" id="crowd-value">--</span>
</div>
<div style="font-size:11px;color:var(--text-muted);margin-top:5px" id="crowd-desc">–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...</div>
</div>
<div class="risk-item light">
<div class="risk-item-header">
<span class="risk-item-title">üí° –û—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç—å</span>
<span class="risk-item-icon">üåô</span>
</div>
<div class="risk-indicator">
<div class="risk-bar"><div class="risk-fill risk-low" id="light-bar" style="width: 0%"></div></div>
<span class="risk-value" id="light-value">--</span>
</div>
<div style="font-size:11px;color:var(--text-muted);margin-top:5px" id="light-desc">–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...</div>
</div>
<div class="risk-item time">
<div class="risk-item-header">
<span class="risk-item-title">üïê –í—Ä–µ–º—è —Å—É—Ç–æ–∫</span>
<span class="risk-item-icon">‚è∞</span>
</div>
<div class="risk-indicator">
<div class="risk-bar"><div class="risk-fill risk-low" id="time-bar" style="width: 0%"></div></div>
<span class="risk-value" id="time-value">--</span>
</div>
<div style="font-size:11px;color:var(--text-muted);margin-top:5px" id="time-desc">–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...</div>
</div>
<div class="risk-item day">
<div class="risk-item-header">
<span class="risk-item-title">üìÖ –î–µ–Ω—å –Ω–µ–¥–µ–ª–∏</span>
<span class="risk-item-icon">üìÜ</span>
</div>
<div class="risk-indicator">
<div class="risk-bar"><div class="risk-fill risk-low" id="day-bar" style="width: 0%"></div></div>
<span class="risk-value" id="day-value">--</span>
</div>
<div style="font-size:11px;color:var(--text-muted);margin-top:5px" id="day-desc">–î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...</div>
</div>
</div>
<div class="card">
<div class="card-title"><span class="icon">üå§Ô∏è</span>–ü–æ–≥–æ–¥–∞</div>
<div class="data-row"><span class="data-label">–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞:</span><span class="data-value" id="w-temp">‚Äî</span></div>
<div class="data-row"><span class="data-label">–°–æ—Å—Ç–æ—è–Ω–∏–µ:</span><span class="data-value" id="w-cond">‚Äî</span></div>
<div class="data-row"><span class="data-label">–í–µ—Ç–µ—Ä:</span><span class="data-value" id="w-wind">‚Äî</span></div>
<div class="data-row"><span class="data-label">–í–ª–∞–∂–Ω–æ—Å—Ç—å:</span><span class="data-value" id="w-hum">‚Äî</span></div>
</div>
<div class="card">
<div class="card-title"><span class="icon">üöó</span>–ü—Ä–æ–±–∫–∏</div>
<div class="data-row"><span class="data-label">–£—Ä–æ–≤–µ–Ω—å:</span><span class="data-value" id="t-level">5/10</span></div>
<div class="data-row"><span class="data-label">–°–∫–æ—Ä–æ—Å—Ç—å:</span><span class="data-value" id="t-speed">25 –∫–º/—á</span></div>
<div class="data-row"><span class="data-label">–°—Ç–∞—Ç—É—Å:</span><span class="data-value" id="t-status" class="traffic-medium">–£–º–µ—Ä–µ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å</span></div>
</div>
</div>
<footer>
<p>UrbanBlind ¬© 2026 | Yandex Maps ‚Ä¢ OpenStreetMap ‚Ä¢ Open-Meteo ‚Ä¢ TomTom</p>
<p style="font-size:10px;margin-top:5px;color:var(--text-muted)">–•–∞–∫–∞—Ç–æ–Ω ¬´–£–º–Ω—ã–π –≥–æ—Ä–æ–¥¬ª ‚Äî –ê–Ω–∞–ª–∏–∑ —Ñ–∞–∫—Ç–æ—Ä–æ–≤ —Ä–∏—Å–∫–∞</p>
</footer>
</div>
<script src="https://api-maps.yandex.ru/2.1/?apikey=c2763cd1-5a14-4131-842c-2bbd60932c52&lang=ru_RU" type="text/javascript"></script>
<script>
// --- –ù–ê–°–¢–†–û–ô–ö–ò ---
const CONFIG = {
    throttleMs: 600,
    minDragDistance: 0.001,
    apiBase: 'http://127.0.0.1:5000/api', // –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    defaultCoords: [55.7961, 49.1064],
    debugMode: false,
    overpassUrl: 'https://overpass-api.de/api/interpreter',
    openMeteoUrl: 'https://api.open-meteo.com/v1/forecast',
    sunriseUrl: 'https://api.sunrise-sunset.org/json',
    overpassTimeout: 25,
    cacheDuration: 300000,
    // --- –ù–û–í–´–ï –ö–õ–Æ–ß–ò ---
    meersensApiKey: 'YOUR_MEERSENS_API_KEY', // <- –ó–ê–ú–ï–ù–ò–¢–ï –ù–ê –°–í–û–ô
    meersensBaseUrl: 'https://api.meersens.com/environment/public/noise/current',
    tomTomApiKey: 'YOUR_TOMTOM_API_KEY', // <- –ó–ê–ú–ï–ù–ò–¢–ï –ù–ê –°–í–û–ô
    tomTomBaseUrl: 'https://api.tomtom.com/traffic/services/4/flowSegmentData/absolute/11/json'
};

// --- –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ---
let map, placemark;
let currentCoords = [...CONFIG.defaultCoords];
let lastRequestTime = 0;
let lastRequestCoords = null;
let isDragging = false;
let pendingRequest = null;
let savedPoints = JSON.parse(localStorage.getItem('smartKazanPoints') || '[]');
let activePointId = null;
let requestCounter = 0;
let mapInitialized = false;
let apiCache = new Map();

// --- –§–£–ù–ö–¶–ò–ò ---
function throttle(func, limitMs, label = '') {
    return function(...args) {
        const now = Date.now();
        const coords = args[0];
        if (lastRequestCoords) {
            const dist = Math.hypot(coords[0] - lastRequestCoords[0], coords[1] - lastRequestCoords[1]);
            if (dist < CONFIG.minDragDistance && now - lastRequestTime < limitMs * 2) {
                return;
            }
        }
        if (now - lastRequestTime >= limitMs) {
            lastRequestTime = now;
            lastRequestCoords = [...coords];
            func.apply(this, args);
        } else {
            if (pendingRequest) clearTimeout(pendingRequest);
            pendingRequest = setTimeout(() => {
                lastRequestTime = Date.now();
                lastRequestCoords = [...coords];
                func.apply(this, args);
                pendingRequest = null;
            }, limitMs - (now - lastRequestTime));
        }
    };
}

function formatCoord(val) { return val.toFixed(4); }

function getTrafficClass(level) {
    if (level > 7) return 'traffic-high';
    if (level > 4) return 'traffic-medium';
    return 'traffic-low';
}

function getCachedData(key) {
    const cached = apiCache.get(key);
    if (cached && Date.now() - cached.time < CONFIG.cacheDuration) {
        return cached.data;
    }
    return null;
}

function setCachedData(key, data) {
    apiCache.set(key, { data, time: Date.now() });
}

// --- –ü–û–ì–û–î–ê (–ò–°–ü–†–ê–í–õ–ï–ù–û) ---
async function getWeatherFromOpenMeteo(lat, lon) {
    const cacheKey = `weather:${lat.toFixed(2)},${lon.toFixed(2)}`;
    const cached = getCachedData(cacheKey);
    if (cached) {
        return cached;
    }
    try {
        const url = `${CONFIG.openMeteoUrl}?` +
            `latitude=${lat}&` +
            `longitude=${lon}&` +
            `current_weather=true&` +
            `hourly=relative_humidity_2m&` +
            `timezone=auto&` +
            `forecast_days=1`;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const response = await fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' },
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        if (!data.current_weather) throw new Error('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Ç–µ–∫—É—â–µ–π –ø–æ–≥–æ–¥–µ');

        let humidity = 0;
        if (data.hourly && data.hourly.time && data.hourly.relative_humidity_2m) {
            const now = new Date();
            const currentHourStr = now.toISOString().slice(0, 13);
            const index = data.hourly.time.findIndex(t => t.startsWith(currentHourStr));
            if (index !== -1 && data.hourly.relative_humidity_2m[index] !== undefined) {
                humidity = data.hourly.relative_humidity_2m[index];
            } else {
                humidity = data.hourly.relative_humidity_2m[0] || 0;
            }
        }
        const weather = {
            temp: data.current_weather.temperature ?? 0,
            wind: `${data.current_weather.windspeed ?? 0} –º/—Å`,
            windDirection: getWindDirection(data.current_weather.winddirection),
            humidity: humidity,
            condition: getWeatherCondition(data.current_weather.weathercode),
            weatherCode: data.current_weather.weathercode
        };
        setCachedData(cacheKey, weather);
        return weather;
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–≥–æ–¥—ã:", error);
        return {
            temp: 0, wind: '‚Äî', windDirection: '‚Äî', humidity: 0,
            condition: '–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ', weatherCode: null, error: error.message
        };
    }
}

function getWindDirection(degrees) {
    if (degrees === undefined || degrees === null) return '‚Äî';
    const directions = ['–°', '–°–í', '–í', '–Æ–í', '–Æ', '–Æ–ó', '–ó', '–°–ó'];
    const index = Math.round(degrees / 45) % 8;
    return directions[index];
}

function getWeatherCondition(code) {
    const conditions = {
        0: '‚òÄÔ∏è –Ø—Å–Ω–æ', 1: 'üå§Ô∏è –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–µ–Ω–Ω–æ —è—Å–Ω–æ', 2: '‚õÖ –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–±–ª–∞—á–Ω–æ—Å—Ç—å',
        3: '‚òÅÔ∏è –ü–∞—Å–º—É—Ä–Ω–æ', 45: 'üå´Ô∏è –¢—É–º–∞–Ω', 48: '‚ùÑÔ∏è –ò–Ω–µ–π',
        51: 'üíß –ú–æ—Ä–æ—Å—å', 53: 'üíß –ú–æ—Ä–æ—Å—å', 55: 'üíß –ú–æ—Ä–æ—Å—å',
        61: 'üåßÔ∏è –î–æ–∂–¥—å', 63: 'üåßÔ∏è –î–æ–∂–¥—å', 65: 'üåßÔ∏è –°–∏–ª—å–Ω—ã–π –¥–æ–∂–¥—å',
        71: '‚ùÑÔ∏è –°–Ω–µ–≥', 73: '‚ùÑÔ∏è –°–Ω–µ–≥', 75: '‚ùÑÔ∏è –°–∏–ª—å–Ω—ã–π —Å–Ω–µ–≥',
        80: 'üå¶Ô∏è –õ–∏–≤–µ–Ω—å', 81: 'üå¶Ô∏è –õ–∏–≤–µ–Ω—å', 82: 'üå¶Ô∏è –°–∏–ª—å–Ω—ã–π –ª–∏–≤–µ–Ω—å',
        95: '‚õàÔ∏è –ì—Ä–æ–∑–∞', 96: '‚õàÔ∏è –ì—Ä–æ–∑–∞ —Å –≥—Ä–∞–¥–æ–º', 99: '‚õàÔ∏è –°–∏–ª—å–Ω–∞—è –≥—Ä–æ–∑–∞ —Å –≥—Ä–∞–¥–æ–º'
    };
    return conditions[code] || '‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
}

// --- –ü–†–û–ë–ö–ò (–ò–°–ü–†–ê–í–õ–ï–ù–û) ---
async function getTrafficFromTomTom(lat, lon) {
    const cacheKey = `tomtom:${lat.toFixed(4)},${lon.toFixed(4)}`;
    const cached = getCachedData(cacheKey);
    if (cached) return cached;

    try {
        const url = `${CONFIG.tomTomBaseUrl}/${CONFIG.tomTomApiKey}?point=${lat},${lon}`;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const response = await fetch(url, {
            headers: { 'Accept': 'application/json' },
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        if (!data.flowSegmentData || !data.flowSegmentData.currentSpeed) {
            throw new Error('Invalid response format');
        }
        const { currentSpeed, freeFlowSpeed, roadClosure } = data.flowSegmentData;
        let trafficLevel = 0;
        if (roadClosure) {
            trafficLevel = 10;
        } else if (freeFlowSpeed > 0) {
            const speedRatio = currentSpeed / freeFlowSpeed;
            trafficLevel = Math.min(10, Math.round((1 - speedRatio) * 10));
        }
        let status, speedAvg;
        if (roadClosure) {
            status = '–î–æ—Ä–æ–≥–∞ –∑–∞–∫—Ä—ã—Ç–∞';
            speedAvg = '0 –∫–º/—á';
        } else if (trafficLevel > 7) {
            status = '–í—ã—Å–æ–∫–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å';
            speedAvg = `${Math.min(20, currentSpeed)} –∫–º/—á`;
        } else if (trafficLevel > 4) {
            status = '–£–º–µ—Ä–µ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å';
            speedAvg = `${Math.min(30, currentSpeed)} –∫–º/—á`;
        } else {
            status = '–ù–∏–∑–∫–∞—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å';
            speedAvg = `${Math.min(50, currentSpeed)} –∫–º/—á`;
        }
        const trafficData = {
            level: trafficLevel,
            status: status,
            speed_avg: speedAvg,
            current_speed: currentSpeed,
            free_flow_speed: freeFlowSpeed,
            road_closure: roadClosure
        };
        setCachedData(cacheKey, trafficData);
        return trafficData;
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–±–æ–∫:", error);
        // Fallback –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ API
        return {
            level: 5,
            status: '–î–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã',
            speed_avg: '--'
        };
    }
}

// --- –®–£–ú (–ò–°–ü–†–ê–í–õ–ï–ù–û: —Ç–µ–ø–µ—Ä—å —á–µ—Ä–µ–∑ API Meersens) ---
async function getNoiseFromMeersens(lat, lon) {
    const cacheKey = `meersens:${lat.toFixed(4)},${lon.toFixed(4)}`;
    const cached = getCachedData(cacheKey);
    if (cached) {
        cached.source = 'meersens-cached';
        return cached;
    }
    try {
        const url = `${CONFIG.meersensBaseUrl}?lat=${lat}&lng=${lon}`;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000);
        const response = await fetch(url, {
            headers: { 'apikey': CONFIG.meersensApiKey, 'Accept': 'application/json' },
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        let noiseLevel = null;
        if (data.noise) {
            noiseLevel = data.noise.Lden || data.noise.Lday || data.noise.Lnight || data.noise.average;
        }
        if (noiseLevel !== null && noiseLevel !== undefined) {
            const risk = Math.min(100, Math.max(0, ((noiseLevel - 30) / 55) * 100));
            const result = {
                level: Math.round(noiseLevel),
                risk: Math.round(risk),
                desc: getNoiseDescription(noiseLevel),
                source: 'meersens',
                data: data
            };
            setCachedData(cacheKey, result);
            return result;
        } else {
            throw new Error('No noise data in response');
        }
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —à—É–º–∞:", error);
        // Fallback –µ—Å–ª–∏ API –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
        return {
            level: 45,
            risk: 30,
            desc: '–î–∞–Ω–Ω—ã–µ —à—É–º–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã',
            source: 'fallback'
        };
    }
}

function getNoiseDescription(db) {
    if (db < 45) return '–¢–∏—Ö–æ: —Å–ø–æ–∫–æ–π–Ω–∞—è –∑–æ–Ω–∞, –Ω–∏–∑–∫–∏–π —Ä–∏—Å–∫ –¥–ª—è —Å–ª—É—Ö–∞';
    if (db < 55) return '–£–º–µ—Ä–µ–Ω–Ω—ã–π —à—É–º: –∂–∏–ª–∞—è –∑–æ–Ω–∞, –∫–æ–º—Ñ–æ—Ä—Ç–Ω–æ';
    if (db < 65) return '–ó–∞–º–µ—Ç–Ω—ã–π —à—É–º: –æ–∂–∏–≤–ª—ë–Ω–Ω–∞—è —É–ª–∏—Ü–∞, –≤–æ–∑–º–æ–∂–Ω–∞ —É—Å—Ç–∞–ª–æ—Å—Ç—å';
    if (db < 75) return '–®—É–º–Ω–æ: —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∞—è –º–∞–≥–∏—Å—Ç—Ä–∞–ª—å, —Ä–∏—Å–∫ –ø—Ä–∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ–º –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏–∏';
    return '–û—á–µ–Ω—å —à—É–º–Ω–æ: –∑–æ–Ω–∞ –≤—ã—Å–æ–∫–æ–≥–æ —Ä–∏—Å–∫–∞, —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∑–∞—â–∏—Ç–∞ —Å–ª—É—Ö–∞';
}

// --- –ü–õ–û–¢–ù–û–°–¢–¨ –õ–Æ–î–ï–ô (–ò–°–ü–†–ê–í–õ–ï–ù–û: —Ç–µ–ø–µ—Ä—å —á–µ—Ä–µ–∑ Overpass API) ---
async function getCrowdFromOSM(lat, lon) {
    const cacheKey = `crowd:${lat.toFixed(4)},${lon.toFixed(4)}`;
    const cached = getCachedData(cacheKey);
    if (cached) {
        return cached;
    }
    const query = `
[out:json][timeout:${CONFIG.overpassTimeout}];
(
  node["amenity"="cafe"](around:200,${lat},${lon});
  node["amenity"="bar"](around:200,${lat},${lon});
  node["amenity"="pub"](around:200,${lat},${lon});
  node["amenity"="fast_food"](around:200,${lat},${lon});
  node["amenity"="restaurant"](around:200,${lat},${lon});
  node["amenity"="cinema"](around:200,${lat},${lon});
  node["amenity"="theatre"](around:200,${lat},${lon});
  node["amenity"="library"](around:200,${lat},${lon});
  node["amenity"="university"](around:200,${lat},${lon});
  node["amenity"="college"](around:200,${lat},${lon});
  node["amenity"="school"](around:200,${lat},${lon});
  node["amenity"="hospital"](around:200,${lat},${lon});
  node["shop"](around:200,${lat},${lon});
  way["building"="retail"](around:200,${lat},${lon});
  way["building"="commercial"](around:200,${lat},${lon});
  relation["amenity"="marketplace"](around:200,${lat},${lon});
  relation["building"="retail"](around:200,${lat},${lon});
  relation["building"="commercial"](around:200,${lat},${lon});
  relation["leisure"="park"](around:200,${lat},${lon});
  relation["leisure"="playground"](around:200,${lat},${lon});
  relation["highway"="pedestrian"](around:200,${lat},${lon});
  relation["highway"="footway"](around:200,${lat},${lon});
  relation["highway"="cycleway"](around:200,${lat},${lon});
  relation["amenity"="bus_station"](around:200,${lat},${lon});
  node["public_transport"="station"](around:200,${lat},${lon});
  node["public_transport"="platform"](around:200,${lat},${lon});
  node["highway"="bus_stop"](around:200,${lat},${lon});
);
out geom;
`;
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const response = await fetch(CONFIG.overpassUrl, {
            method: 'POST',
            body: query,
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        const elements = data.elements || [];
        // –ü—Ä–æ—Å—Ç–æ–π –ø–æ–¥—Å—á–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤ –∫–∞–∫ –ø—Ä–∏–∑–Ω–∞–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        let activityScore = elements.length;
        let level, risk, desc;
        if (activityScore > 50) { level = 85; risk = 65; desc = '–í—ã—Å–æ–∫–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∑–æ–Ω–∞'; }
        else if (activityScore > 25) { level = 60; risk = 45; desc = '–°—Ä–µ–¥–Ω—è—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: –∫–æ–º–º–µ—Ä—á–µ—Å–∫–∞—è –∑–æ–Ω–∞'; }
        else if (activityScore > 10) { level = 35; risk = 25; desc = '–ù–∏–∑–∫–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: –∂–∏–ª–∞—è –∑–æ–Ω–∞'; }
        else { level = 15; risk = 15; desc = '–û—á–µ–Ω—å –Ω–∏–∑–∫–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å: —Ç–∏—Ö–∞—è –∑–æ–Ω–∞'; }
        const result = { level, risk, desc, source: 'osm' };
        setCachedData(cacheKey, result);
        return result;
    } catch (e) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ –ª—é–¥–µ–π:", e);
        return {
            level: 25,
            risk: 20,
            desc: '–î–∞–Ω–Ω—ã–µ –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã',
            source: 'fallback'
        };
    }
}

// --- –û–°–í–ï–©–ï–ù–ù–û–°–¢–¨ (–ò–°–ü–†–ê–í–õ–ï–ù–û: —á–µ—Ä–µ–∑ Overpass API + –∞–Ω–∞–ª–∏–∑ –≤—Ä–µ–º–µ–Ω–∏) ---
async function getLightFromOSM(lat, lon) {
    const cacheKey = `light:${lat.toFixed(4)},${lon.toFixed(4)}`;
    const cached = getCachedData(cacheKey);
    if (cached) {
        return cached;
    }
    const now = new Date();
    const timeInfo = await getTimeOfDayByLocation(lat, lon);
    const isDaytime = timeInfo.isDaytime;

    if (isDaytime) {
        return { level: 95, risk: 10, desc: '–ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ (–¥–µ–Ω—å)', source: 'time_calc' };
    }

    const query = `
[out:json][timeout:${CONFIG.overpassTimeout}];
(
  node["highway"="street_lamp"](around:200,${lat},${lon});
  node["man_made"="street_lamp"](around:200,${lat},${lon});
  way["lighting"](around:200,${lat},${lon});
  node["amenity"="street_light"](around:200,${lat},${lon});
);
out count;
`;
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const response = await fetch(CONFIG.overpassUrl, {
            method: 'POST',
            body: query,
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        const count = data.elements?.length || 0;
        let level, risk, desc;
        if (count > 15) { level = 75; risk = 25; desc = '–•–æ—Ä–æ—à–µ–µ —É–ª–∏—á–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ'; }
        else if (count > 5) { level = 50; risk = 45; desc = '–°—Ä–µ–¥–Ω–µ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ'; }
        else { level = 25; risk = 70; desc = '–°–ª–∞–±–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ'; }
        const result = { level, risk, desc, source: 'osm' };
        setCachedData(cacheKey, result);
        return result;
    } catch (e) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç–∏:", e);
        return {
            level: 25,
            risk: 70,
            desc: '–î–∞–Ω–Ω—ã–µ –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã',
            source: 'fallback'
        };
    }
}

// --- –í–†–ï–ú–Ø –°–£–¢–û–ö ---
async function getSunriseSunset(lat, lon) {
    const cacheKey = `sunrise:${lat.toFixed(4)},${lon.toFixed(4)}`;
    const cached = getCachedData(cacheKey);
    if (cached) return cached;
    try {
        const url = `https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&date=today&formatted=0`;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        if (!data.results || !data.results.sunrise) throw new Error('Invalid response format');
        const result = {
            sunrise: new Date(data.results.sunrise),
            sunset: new Date(data.results.sunset),
            solar_noon: new Date(data.results.solar_noon),
            civil_twilight_begin: new Date(data.results.civil_twilight_begin),
            civil_twilight_end: new Date(data.results.civil_twilight_end)
        };
        setCachedData(cacheKey, result);
        return result;
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤–æ—Å—Ö–æ–¥–∞/–∑–∞–∫–∞—Ç–∞:", error);
        return null;
    }
}

async function getTimeOfDayByLocation(lat, lon) {
    const now = new Date();
    const sunData = await getSunriseSunset(lat, lon);
    if (!sunData) {
        const hour = now.getHours();
        return {
            timeOfDay: hour >= 6 && hour < 12 ? '–£—Ç—Ä–æ' : hour >= 12 && hour < 18 ? '–î–µ–Ω—å' : hour >= 18 && hour < 23 ? '–í–µ—á–µ—Ä' : '–ù–æ—á—å',
            isDaytime: hour >= 6 && hour < 22,
            description: '–õ–æ–∫–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è'
        };
    }
    const isDaytime = now >= sunData.sunrise && now < sunData.sunset;
    let timeOfDay, description;
    if (now < sunData.sunrise) { timeOfDay = '–ù–æ—á—å'; description = '–¢–µ–º–Ω–æ, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å'; }
    else if (now < new Date(sunData.sunrise.getTime() + 2 * 60 * 60 * 1000)) { timeOfDay = '–£—Ç—Ä–æ'; description = '–ê–∫—Ç–∏–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ, —Ö–æ—Ä–æ—à–∏–π –æ–±–∑–æ—Ä'; }
    else if (now < sunData.sunset) { timeOfDay = '–î–µ–Ω—å'; description = '–í—ã—Å–æ–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å, —Ö–æ—Ä–æ—à–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å'; }
    else if (now < sunData.civil_twilight_end) { timeOfDay = '–í–µ—á–µ—Ä'; description = '–£–º–µ—Ä–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å, –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–Ω–∏–∂–∞–µ—Ç—Å—è'; }
    else { timeOfDay = '–ù–æ—á—å'; description = '–¢–µ–º–Ω–æ, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å'; }
    return { timeOfDay, isDaytime, description };
}

// --- –†–ê–°–ß–ï–¢ –†–ò–°–ö–û–í ---
async function calculateRiskFactors(coords, serverData = null) {
    const [lat, lon] = coords;
    const now = new Date();
    const day = now.getDay();
    const timeInfo = await getTimeOfDayByLocation(lat, lon);
    const timeOfDay = timeInfo.timeOfDay;
    const timeDesc = timeInfo.description;
    let timeRisk;
    if (timeOfDay === '–ù–æ—á—å') { timeRisk = 75; }
    else if (timeOfDay === '–í–µ—á–µ—Ä') { timeRisk = 60; }
    else if (timeOfDay === '–£—Ç—Ä–æ') { timeRisk = 30; }
    else { timeRisk = 40; }
    const dayNames = ['–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ', '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞'];
    const dayName = dayNames[day];
    let dayRisk, dayDesc;
    if (day === 0 || day === 6) { dayRisk = 35; dayDesc = '–í—ã—Ö–æ–¥–Ω–æ–π: –º–µ–Ω—å—à–µ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞, –±–æ–ª—å—à–µ –ø–µ—à–µ—Ö–æ–¥–æ–≤'; }
    else if (day === 5) { dayRisk = 70; dayDesc = '–ü—è—Ç–Ω–∏—Ü–∞: –≤–µ—á–µ—Ä–Ω–∏–µ –ø—Ä–æ–±–∫–∏, —É—Å—Ç–∞–ª–æ—Å—Ç—å –ø–æ—Å–ª–µ –Ω–µ–¥–µ–ª–∏'; }
    else { dayRisk = 55; dayDesc = '–ë—É–¥–Ω–∏–π –¥–µ–Ω—å: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞'; }

    const [noiseData, crowdData, lightData, weatherData, trafficData] = await Promise.allSettled([
        getNoiseFromMeersens(lat, lon),
        getCrowdFromOSM(lat, lon),
        getLightFromOSM(lat, lon),
        getWeatherFromOpenMeteo(lat, lon),
        getTrafficFromTomTom(lat, lon)
    ]);

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å —É—á–µ—Ç–æ–º fallback
    let noise = noiseData.status === 'fulfilled' ? noiseData.value : {
        level: 45, risk: 30, desc: '–î–∞–Ω–Ω—ã–µ —à—É–º–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã', source: 'fallback'
    };
    let crowd = crowdData.status === 'fulfilled' ? crowdData.value : {
        level: 25, risk: 20, desc: '–î–∞–Ω–Ω—ã–µ –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã', source: 'fallback'
    };
    let light = lightData.status === 'fulfilled' ? lightData.value : {
        level: 25, risk: 70, desc: '–î–∞–Ω–Ω—ã–µ –æ—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã', source: 'fallback'
    };
    let weather = weatherData.status === 'fulfilled' ? weatherData.value : {
        temp: 0, condition: '–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ', wind: '‚Äî', humidity: 0
    };
    let traffic = trafficData.status === 'fulfilled' ? trafficData.value : {
        level: 5, status: '–î–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã', speed_avg: '--'
    };

    // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å)
    if (serverData?.risks) {
        const r = serverData.risks;
        if (r.noise) { noise = { ...noise, ...r.noise }; }
        if (r.crowd) { crowd = { ...crowd, ...r.crowd }; }
        if (r.light) { light = { ...light, ...r.light }; }
        if (r.traffic) { traffic = { ...traffic, ...r.traffic }; }
    }

    const trafficRisk = traffic.level * 10;
    const avgRisk = (noise.risk + crowd.risk + light.risk + timeRisk + dayRisk + trafficRisk) / 6;
    const safetyIndex = Math.round(100 - avgRisk);

    return {
        noise, crowd, light,
        time: { value: timeOfDay, risk: timeRisk, desc: timeDesc },
        day: { value: dayName, risk: dayRisk, desc: dayDesc },
        traffic, weather, safetyIndex,
        timestamp: new Date().toLocaleString('ru')
    };
}

function getRiskClass(risk) {
    if (risk < 40) return 'risk-low';
    if (risk < 70) return 'risk-medium';
    return 'risk-high';
}

function getSafetyColor(index) {
    if (index >= 70) return '#27ae60';
    if (index >= 40) return '#f39c12';
    return '#e74c3c';
}

function getSafetyLabel(index) {
    if (index >= 80) return 'üü¢ –û—á–µ–Ω—å –±–µ–∑–æ–ø–∞—Å–Ω–æ';
    if (index >= 60) return 'üü° –ë–µ–∑–æ–ø–∞—Å–Ω–æ';
    if (index >= 40) return 'üü† –£–º–µ—Ä–µ–Ω–Ω—ã–π —Ä–∏—Å–∫';
    if (index >= 20) return 'üî¥ –ü–æ–≤—ã—à–µ–Ω–Ω—ã–π —Ä–∏—Å–∫';
    return '‚ö´ –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫';
}

// --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–ê–†–¢–´ ---
ymaps.ready(init);

function init() {
    try {
        map = new ymaps.Map('map', {
            center: CONFIG.defaultCoords,
            zoom: 13,
            controls: ['zoomControl', 'fullscreenControl', 'geolocationControl']
        });
        // –ü—Ä–æ–±–∫–∏ –Ø–Ω–¥–µ–∫—Å–∞
        try {
            new ymaps.layer.TrafficLayer({ trafficProvider: 'yandex#actual' }).setMap(map);
        } catch(e) { console.warn("–ü—Ä–æ–±–∫–∏ –Ø–Ω–¥–µ–∫—Å–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã:", e); }

        createPlacemark(CONFIG.defaultCoords);
        mapInitialized = true;
        map.events.add('click', function(e) {
            const coords = e.get('coords');
            movePlacemark(coords, true);
        });
        checkServer();
        requestWeatherData(CONFIG.defaultCoords, true);
        document.getElementById('btn-force-refresh').addEventListener('click', forceRefresh);
        document.getElementById('btn-save').addEventListener('click', saveCurrentPoint);
    } catch (error) {
        showMapError(error);
    }
}

function showMapError(error) {
    const errorEl = document.getElementById('map-error');
    errorEl.classList.add('visible');
}

function createPlacemark(coords) {
    if (placemark) map.geoObjects.remove(placemark);
    placemark = new ymaps.Placemark(coords, {
        hintContent: 'üéØ –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ä–∏—Å–∫–æ–≤',
        balloonContentHeader: '–í—ã–±—Ä–∞–Ω–Ω–∞—è —Ç–æ—á–∫–∞',
        balloonContentBody: '–§–∞–∫—Ç–æ—Ä—ã —Ä–∏—Å–∫–∞ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏'
    }, {
        preset: 'islands#redStretchyIcon',
        draggable: true,
        iconColor: '#e74c3c'
    });
    placemark.events.add('dragstart', () => { isDragging = true; });
    placemark.events.add('drag', (e) => {
        const coords = placemark.geometry.getCoordinates();
        updateCoordsDisplay(coords);
        currentCoords = coords;
        throttledRequest(coords);
    });
    placemark.events.add('dragend', () => {
        isDragging = false;
        const coords = placemark.geometry.getCoordinates();
        requestWeatherData(coords, true);
    });
    map.geoObjects.add(placemark);
}

function movePlacemark(coords, forceUpdate = false) {
    if (placemark) {
        placemark.geometry.setCoordinates(coords);
    } else {
        createPlacemark(coords);
        return;
    }
    map.panTo(coords, { duration: 250, flying: true });
    updateCoordsDisplay(coords);
    currentCoords = coords;
    if (forceUpdate) {
        requestWeatherData(coords, true);
    } else {
        throttledRequest(coords);
    }
}

function updateCoordsDisplay(coords) {
    document.getElementById('coords-display').textContent =
        `–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: ${formatCoord(coords[0])}, ${formatCoord(coords[1])}`;
}

const throttledRequest = throttle(
    (coords) => requestWeatherData(coords, false),
    CONFIG.throttleMs,
    'DRAG'
);

// --- –û–°–ù–û–í–ù–û–ô –ó–ê–ü–†–û–° –î–ê–ù–ù–´–• ---
async function requestWeatherData(coords, force = false) {
    requestCounter++;
    if (!force && lastRequestCoords &&
        Math.abs(coords[0] - lastRequestCoords[0]) < 0.0001 &&
        Math.abs(coords[1] - lastRequestCoords[1]) < 0.0001) {
        return;
    }
    showLoader(true);
    try {
        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å —Å–µ—Ä–≤–µ—Ä–∞ (–µ—Å–ª–∏ –æ–Ω –¥–æ—Å—Ç—É–ø–µ–Ω)
        let serverData = { now: {} };
        try {
            const timestamp = Date.now();
            const response = await fetch(`${CONFIG.apiBase}/analyze?t=${timestamp}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Cache-Control': 'no-cache' },
                body: JSON.stringify({ lat: coords[0], lon: coords[1], timestamp: timestamp }),
                timeout: 5000
            });
            if (response.ok) {
                serverData = await response.json();
            }
        } catch (err) {
            console.info("–°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ API:", err);
        }

        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∏—Å–∫–∏ (—Å–µ—Ä–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –æ–±—ä–µ–¥–∏–Ω–µ–Ω—ã)
        const risks = await calculateRiskFactors(coords, serverData);
        serverData.risks = risks;
        renderData(serverData, coords);
        updateStatus('ok');
    } catch (err) {
        console.error("–û—à–∏–±–∫–∞ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞:", err);
        // –í—Å—ë —Ä–∞–≤–Ω–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∏ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º, –¥–∞–∂–µ –µ—Å–ª–∏ –±—ã–ª–∏ –æ—à–∏–±–∫–∏
        const risks = await calculateRiskFactors(coords, { now: {} });
        renderData({ now: {}, risks }, coords);
        updateStatus('warning', '–î–∞–Ω–Ω—ã–µ —á–∞—Å—Ç–∏—á–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã');
    } finally {
        showLoader(false);
    }
}

function forceRefresh() {
    apiCache.clear();
    requestWeatherData(currentCoords, true);
}

function renderData(data, coords) {
    const w = data?.risks?.weather || data?.now?.weather || {};
    const risks = data?.risks;
    const safetyIndex = risks?.safetyIndex || 0;
    const safetyEl = document.getElementById('safety-index-value');
    const safetyLabel = document.getElementById('safety-index-label');
    const safetyCard = document.getElementById('safety-index-card');

    safetyEl.textContent = safetyIndex;
    safetyEl.style.color = 'white';
    const safetyColor = getSafetyColor(safetyIndex);
    let darkColor;
    if (safetyIndex >= 70) { darkColor = '#1e8449'; }
    else if (safetyIndex >= 40) { darkColor = '#d35400'; }
    else { darkColor = '#c0392b'; }
    safetyLabel.textContent = getSafetyLabel(safetyIndex);
    safetyCard.style.background = `linear-gradient(135deg, ${safetyColor} 0%, ${darkColor} 100%)`;
    safetyCard.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.15)';

    updateRiskItem('noise', risks?.noise?.level, risks?.noise?.risk, risks?.noise?.desc);
    updateRiskItem('crowd', risks?.crowd?.level, risks?.crowd?.risk, risks?.crowd?.desc);
    updateRiskItem('light', risks?.light?.level, risks?.light?.risk, risks?.light?.desc);
    updateRiskItem('time', null, risks?.time?.risk, risks?.time?.desc, risks?.time?.value);
    updateRiskItem('day', null, risks?.day?.risk, risks?.day?.desc, risks?.day?.value);

    // –ü–æ–≥–æ–¥–∞
    const tempEl = document.getElementById('w-temp');
    const condEl = document.getElementById('w-cond');
    const windEl = document.getElementById('w-wind');
    const humEl = document.getElementById('w-hum');
    if (tempEl) tempEl.textContent = w.temp != null ? `${w.temp}¬∞C` : '‚Äî';
    if (condEl) condEl.textContent = w.condition || '‚Äî';
    if (windEl) windEl.textContent = w.wind || '‚Äî';
    if (humEl) humEl.textContent = w.humidity != null ? `${w.humidity}%` : '‚Äî';

    // –ü—Ä–æ–±–∫–∏
    const t = risks?.traffic || { level: 5, status: '–î–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã', speed_avg: '--' };
    const levelEl = document.getElementById('t-level');
    const speedEl = document.getElementById('t-speed');
    const statusEl = document.getElementById('t-status');
    const level = t.level ?? '‚Äî';
    const status = t.status || '‚Äî';
    const speed = t.speed_avg || '‚Äî';
    if (levelEl) levelEl.textContent = level !== '‚Äî' ? `${level}/10` : '‚Äî';
    if (speedEl) speedEl.textContent = speed;
    if (statusEl) {
        statusEl.textContent = status;
        statusEl.className = 'data-value ' + (level !== '‚Äî' ? getTrafficClass(level) : 'traffic-low');
    }

    document.getElementById('btn-save').style.display = 'inline-block';
}

function updateRiskItem(type, level, risk, desc, valueOverride = null) {
    const bar = document.getElementById(`${type}-bar`);
    const value = document.getElementById(`${type}-value`);
    const description = document.getElementById(`${type}-desc`);
    if (!bar || !value) return;
    const riskClass = getRiskClass(risk);
    bar.className = `risk-fill ${riskClass}`;
    setTimeout(() => { bar.style.width = `${risk}%`; }, 100);
    if (valueOverride !== null) {
        value.textContent = valueOverride;
    } else if (level !== null) {
        value.textContent = `${level}%`;
    } else {
        value.textContent = `${risk}%`;
    }
    if (description) description.textContent = desc;
}

function showLoader(show) {
    const loader = document.getElementById('loader');
    const content = document.getElementById('content');
    loader.classList.toggle('active', show);
    content.style.opacity = show ? '0.7' : '1';
    content.style.pointerEvents = show ? 'none' : 'auto';
}

function updateStatus(state, text = '') {
    const dot = document.getElementById('server-dot');
    const txt = document.getElementById('server-text');
    dot.className = 'status-dot ' + (state === 'ok' ? 'status-good' : state === 'error' ? 'status-error' : 'status-warning');
    txt.textContent = text || (state === 'ok' ? '–û–Ω–ª–∞–π–Ω' : state === 'error' ? '–û—à–∏–±–∫–∞' : '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
}

function saveCurrentPoint() {
    const name = prompt('üìå –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–æ—á–∫–∏:', `–¢–æ—á–∫–∞ #${savedPoints.length + 1}`);
    if (!name?.trim()) return;
    const point = {
        id: Date.now(),
        name: name.trim(),
        coords: [...currentCoords],
        data: null,
        created: new Date().toISOString(),
        updated: null
    };
    savedPoints.unshift(point);
    savePointsToStorage();
    alert('‚úÖ –¢–æ—á–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!');
}

function savePointsToStorage() {
    try { localStorage.setItem('smartKazanPoints', JSON.stringify(savedPoints)); }
    catch(e) {}
}

async function checkServer() {
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 3000);
        const r = await fetch(`${CONFIG.apiBase}/health`, { signal: controller.signal });
        clearTimeout(timeoutId);
        if (r.ok) updateStatus('ok', '–°–µ—Ä–≤–µ—Ä: –û–Ω–ª–∞–π–Ω');
        else throw new Error('HTTP ' + r.status);
    } catch {
        updateStatus('warning', '–°–µ—Ä–≤–µ—Ä: –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
    }
}

setInterval(checkServer, 30000);

setTimeout(() => {
    if (!mapInitialized) {
        showMapError(new Error('Timeout'));
    }
}, 5000);

</script>
</body>
</html>
